// Package apiserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package apiserver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
	CookieAuthScopes = "CookieAuth.Scopes"
)

// Defines values for Action.
const (
	ALLOW Action = "ALLOW"
	DENY  Action = "DENY"
)

// Defines values for ErrorType.
const (
	API ErrorType = "API"
	GW  ErrorType = "GW"
)

// Defines values for HeaderType.
const (
	OBJECT  HeaderType = "OBJECT"
	REQUEST HeaderType = "REQUEST"
	SERVICE HeaderType = "SERVICE"
)

// Defines values for MatchType.
const (
	STRINGEQUAL    MatchType = "STRING_EQUAL"
	STRINGNOTEQUAL MatchType = "STRING_NOT_EQUAL"
)

// Defines values for Operation.
const (
	OperationDELETE    Operation = "DELETE"
	OperationGET       Operation = "GET"
	OperationHEAD      Operation = "HEAD"
	OperationPUT       Operation = "PUT"
	OperationRANGE     Operation = "RANGE"
	OperationRANGEHASH Operation = "RANGEHASH"
	OperationSEARCH    Operation = "SEARCH"
)

// Defines values for Role.
const (
	KEYS   Role = "KEYS"
	OTHERS Role = "OTHERS"
	SYSTEM Role = "SYSTEM"
	USER   Role = "USER"
)

// Defines values for SearchMatch.
const (
	MatchCommonPrefix   SearchMatch = "MatchCommonPrefix"
	MatchNotPresent     SearchMatch = "MatchNotPresent"
	MatchStringEqual    SearchMatch = "MatchStringEqual"
	MatchStringNotEqual SearchMatch = "MatchStringNotEqual"
)

// Defines values for TokenType.
const (
	Container TokenType = "container"
	Object    TokenType = "object"
)

// Defines values for Verb.
const (
	VerbDELETE  Verb = "DELETE"
	VerbPUT     Verb = "PUT"
	VerbSETEACL Verb = "SETEACL"
)

// Action Rule execution result action in NeoFS EACL. Either allows or denies access if the rule's filters match.
type Action string

// Address Address of the object in NeoFS.
type Address struct {
	ContainerId string `json:"containerId"`
	ObjectId    string `json:"objectId"`
}

// AddressForUpload Address of the object in NeoFS.
type AddressForUpload struct {
	ContainerId string `json:"container_id"`
	ObjectId    string `json:"object_id"`
}

// Attribute Attribute is a pair of strings that can be attached to a container or an object.
type Attribute struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Balance defines model for Balance.
type Balance struct {
	Address   string `json:"address"`
	Precision uint32 `json:"precision"`
	Value     string `json:"value"`
}

// Bearer Bearer token that is expected to be formed.
type Bearer struct {
	// Container Container session token rule.
	Container *Rule    `json:"container,omitempty"`
	Name      string   `json:"name,omitempty"`
	Object    []Record `json:"object"`
}

// BinaryBearer Bearer token for object operations that is represented in binary form.
type BinaryBearer struct {
	// Token Base64 encoded bearer token.
	Token string `json:"token"`
}

// ContainerInfo Information about container.
type ContainerInfo struct {
	Attributes []Attribute `json:"attributes"`
	BasicAcl   string      `json:"basicAcl"`

	// CannedAcl The friendly name for the basicAcl field.
	CannedAcl       *string `json:"cannedAcl,omitempty"`
	ContainerId     string  `json:"containerId"`
	ContainerName   string  `json:"containerName"`
	OwnerId         string  `json:"ownerId"`
	PlacementPolicy string  `json:"placementPolicy"`
}

// ContainerList List of containers info
type ContainerList struct {
	Containers []ContainerInfo `json:"containers"`
	Size       int             `json:"size"`
}

// ContainerPutInfo <p>Request body to create container. To specify container name use appropriate property (name provided in attributes will be ignored).<p>
// <p>To create a container you must provide <code>PlacementPolicy</code> and <code>BasicACL</code>.</p>
//
// <h5>Placement policy</h5>
// <p>Placement policy allows you control where and how the container (and its object) is stored. For example, you want to store 3 copies of every object, so you can use the following policy:</p>
// <pre><code>REP 3</code></pre>
// <p><a href="https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/02-policy.md">More about policy</a>.</p>
//
// <h5>Basic ACL</h5>
// <p>Basic ACL is a part of the container structure, and it is always created simultaneously with the container. Therefore, it is never subject to any changes. It is a 32-bit integer with a bit field in the following format:</p>
// <p><img src="https://raw.githubusercontent.com/nspcc-dev/neofs-spec/046e623dc2d8134ab2b85fcaf831077d574561a2/01-arch/pic/acl-basic-private.svg" alt="ACL Basic"></p>
//
// <table>
//
//	<thead>
//	    <tr>
//	        <th>Symbol</th>
//	        <th>Meaning</th>
//	        <th>Description</th>
//	    </tr>
//	</thead>
//	<tbody>
//	    <tr>
//	        <td>B</td>
//	        <td>Bearer</td>
//	        <td>Allows using Bear Token ACL rules to replace eACL rules</td>
//	    </tr>
//	    <tr>
//	        <td>U</td>
//	        <td>User</td>
//	        <td>The owner of the container identified by the public key linked to the container</td>
//	    </tr>
//	    <tr>
//	        <td>S</td>
//	        <td>System</td>
//	        <td>Inner Ring and/or container nodes in the current version of network map. IR nodes can only perform <code>GetRangeHash</code>, <code>Head</code>, and <code>Search</code> necessary for data audit. Container nodes can only do things required for the replication.</td>
//	    </tr>
//	    <tr>
//	        <td>O</td>
//	        <td>Others</td>
//	        <td>Clients that do not match any of the categories above</td>
//	    </tr>
//	    <tr>
//	        <td>F</td>
//	        <td>Final</td>
//	        <td>Flag denying Extended ACL. If set, Basic ACL check is final, Extended ACL is ignored</td>
//	    </tr>
//	    <tr>
//	        <td>X</td>
//	        <td>Sticky</td>
//	        <td>Flag denying different owners of the request and the object. If set, object in <code>Put</code> request must have one <code>Owner</code> and be signed with the same signature. If not set, the object must be correct but can be of any owner. The nodes falling for <code>SYSTEM</code> role are exceptions from this rule. For them, the bit is ignored.</td>
//	    </tr>
//	    <tr>
//	        <td>0</td>
//	        <td>Deny</td>
//	        <td>Denies operation of the identified category</td>
//	    </tr>
//	    <tr>
//	        <td>1</td>
//	        <td>Allow</td>
//	        <td>Allows operation of the identified category</td>
//	    </tr>
//	</tbody>
//
// </table>
// <p>To upload objects with a bearer token your container must have Bearer bits set. For example, you can use <code>0x0FBFBFFF</code> or predefined <code>eacl-public-read-write</code> values.</p>
// <p>Also, don't forget to set appropriate eACL to restrict your container.</p>
// <p><a href="https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/07-acl.md">More about ACL</a>.</p>
type ContainerPutInfo struct {
	Attributes      []Attribute `json:"attributes,omitempty"`
	BasicAcl        string      `json:"basicAcl,omitempty"`
	ContainerName   string      `json:"containerName,omitempty"`
	PlacementPolicy string      `json:"placementPolicy,omitempty"`
}

// Eacl EACL NeoFS table.
type Eacl struct {
	ContainerId string   `json:"containerId"`
	Records     []Record `json:"records"`
}

// ErrorResponse <p>Error response.</p>
// <p>More about NeoFS status code you can find
//
//	<a href="https://github.com/nspcc-dev/neofs-spec/blob/master/20-api-v2/status.md">here</a>.</p>
type ErrorResponse struct {
	Code    uint32 `json:"code,omitempty"`
	Message string `json:"message"`

	// Type Error type. Allow determine source of the error.
	Type ErrorType `json:"type"`
}

// ErrorType Error type. Allow determine source of the error.
type ErrorType string

// Filter Filter in NeoFS EACL to check particular properties of the request or the object.
type Filter struct {
	// HeaderType Enumeration of possible sources of Headers to apply filters in NeoFS EACL.
	HeaderType HeaderType `json:"headerType"`
	Key        string     `json:"key"`

	// MatchType Match type in NeoFS EACL filter.
	MatchType MatchType `json:"matchType"`
	Value     string    `json:"value"`
}

// HeaderType Enumeration of possible sources of Headers to apply filters in NeoFS EACL.
type HeaderType string

// MatchType Match type in NeoFS EACL filter.
type MatchType string

// ObjectBaseInfo Basic object information.
type ObjectBaseInfo struct {
	// Address Address of the object in NeoFS.
	Address  Address `json:"address"`
	FilePath *string `json:"filePath,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// ObjectInfo Object information.
type ObjectInfo struct {
	Attributes  []Attribute `json:"attributes"`
	ContainerId string      `json:"containerId"`
	ObjectId    string      `json:"objectId"`

	// ObjectSize Object full payload size
	ObjectSize uint64 `json:"objectSize"`
	OwnerId    string `json:"ownerId"`

	// Payload Base64 encoded object payload
	Payload *string `json:"payload,omitempty"`

	// PayloadSize Payload size in response
	PayloadSize int64 `json:"payloadSize"`
}

// ObjectList List of objects.
type ObjectList struct {
	Objects []ObjectBaseInfo `json:"objects"`
	Size    int              `json:"size"`
}

// ObjectUpload <p>Request body to create object.</p>
// <p>To create an object you must provide <code>containerId</code> and <code>fileName</code>.
// Additionally, you can provide <code>payload</code> (base64 encoded data) and <code>attributes</code>.</p>
//
// <p>Attribute is key-value data that is stored with the object. Key and value must be in UTF-8 format and must not be empty.</p>
//
// <p>Valid attribute:</p>
// <ul>
//
//	<li><code>MyAttribute: 'some value'</code></li>
//
// </ul>
//
// <p>Invalid attribute:</p>
// <ul>
//
//	<li><code>MyAttribute: ''</code></li>
//
// </ul>
//
// <p>Also, you can use this attribute to further object searching.</p>
type ObjectUpload struct {
	Attributes  []Attribute `json:"attributes,omitempty"`
	ContainerId string      `json:"containerId"`
	FileName    string      `json:"fileName"`
	Payload     *string     `json:"payload,omitempty"`
}

// Operation Request's operation type to match in NeoFS EACL if the rule is applicable to a particular request.
type Operation string

// PutContainerOK defines model for PutContainerOK.
type PutContainerOK struct {
	ContainerId string `json:"containerId"`
}

// Record A single NeoFS EACL rule.
type Record struct {
	// Action Rule execution result action in NeoFS EACL. Either allows or denies access if the rule's filters match.
	Action  Action   `json:"action"`
	Filters []Filter `json:"filters"`

	// Operation Request's operation type to match in NeoFS EACL if the rule is applicable to a particular request.
	Operation Operation `json:"operation"`
	Targets   []Target  `json:"targets"`
}

// Role Role for target in EACL.
type Role string

// Rule Container session token rule.
type Rule struct {
	ContainerId *string `json:"containerId,omitempty"`

	// Verb Verb that describes the allowed container operation for token.
	Verb Verb `json:"verb"`
}

// SearchFilter Search filter to find objects.
type SearchFilter struct {
	Key string `json:"key"`

	// Match Search match type.
	Match SearchMatch `json:"match"`
	Value string      `json:"value"`
}

// SearchFilters List of SearchFilter elements.
type SearchFilters struct {
	Filters []SearchFilter `json:"filters"`
}

// SearchMatch Search match type.
type SearchMatch string

// SuccessResponse Success response.
type SuccessResponse struct {
	Success bool `json:"success"`
}

// Target Target to apply the ACL rule. Can be a subject's role class or a list of public keys to match (KEYS role).
type Target struct {
	Keys []string `json:"keys"`

	// Role Role for target in EACL.
	Role Role `json:"role"`
}

// TokenResponse Base64 encoded marshaled token (for container or for object operations).
type TokenResponse struct {
	Name  *string `json:"name,omitempty"`
	Token string  `json:"token"`

	// Type Type of token.
	Type TokenType `json:"type"`
}

// TokenType Type of token.
type TokenType string

// Verb Verb that describes the allowed container operation for token.
type Verb string

// AttrKey defines model for attrKey.
type AttrKey = string

// AttrVal defines model for attrVal.
type AttrVal = string

// ContainerId defines model for containerId.
type ContainerId = string

// FullBearerToken defines model for fullBearerToken.
type FullBearerToken = bool

// ObjectId defines model for objectId.
type ObjectId = string

// SignatureKeyParam defines model for signatureKeyParam.
type SignatureKeyParam = string

// SignatureParam defines model for signatureParam.
type SignatureParam = string

// SignatureScheme defines model for signatureScheme.
type SignatureScheme = bool

// AuthJSONBody defines parameters for Auth.
type AuthJSONBody = []Bearer

// AuthParams defines parameters for Auth.
type AuthParams struct {
	// XBearerOwnerId Owner Id (wallet address) that will sign the token.
	XBearerOwnerId string `json:"X-Bearer-Owner-Id"`

	// XBearerLifetime Token lifetime in epoch.
	XBearerLifetime *int `json:"X-Bearer-Lifetime,omitempty"`

	// XBearerForAllUsers Form token for all users or only for this gate.
	XBearerForAllUsers *bool `json:"X-Bearer-For-All-Users,omitempty"`
}

// FormBinaryBearerParams defines parameters for FormBinaryBearer.
type FormBinaryBearerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// ListContainersParams defines parameters for ListContainers.
type ListContainersParams struct {
	// OwnerId Base58 encoded owner id.
	OwnerId string `form:"ownerId" json:"ownerId"`

	// Offset The number of containers to skip before starting to collect the result set.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of containers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PutContainerParams defines parameters for PutContainer.
type PutContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// NameScopeGlobal Provide this parameter to register container name in NNS service.
	NameScopeGlobal *bool `form:"name-scope-global,omitempty" json:"name-scope-global,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// DeleteContainerParams defines parameters for DeleteContainer.
type DeleteContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// PutContainerEACLParams defines parameters for PutContainerEACL.
type PutContainerEACLParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// GetContainerObjectParams defines parameters for GetContainerObject.
type GetContainerObjectParams struct {
	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// HeadContainerObjectParams defines parameters for HeadContainerObject.
type HeadContainerObjectParams struct {
	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// GetByAttributeParams defines parameters for GetByAttribute.
type GetByAttributeParams struct {
	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// HeadByAttributeParams defines parameters for HeadByAttribute.
type HeadByAttributeParams struct {
	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// PutObjectParams defines parameters for PutObject.
type PutObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// FullBearer Provided bearer token is final or gate should assemble it using signature.
	FullBearer *FullBearerToken `form:"fullBearer,omitempty" json:"fullBearer,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// SearchObjectsParams defines parameters for SearchObjects.
type SearchObjectsParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// FullBearer Provided bearer token is final or gate should assemble it using signature.
	FullBearer *FullBearerToken `form:"fullBearer,omitempty" json:"fullBearer,omitempty"`

	// Offset The number of containers to skip before starting to collect the result set.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of containers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// FullBearer Provided bearer token is final or gate should assemble it using signature.
	FullBearer *FullBearerToken `form:"fullBearer,omitempty" json:"fullBearer,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// GetObjectInfoParams defines parameters for GetObjectInfo.
type GetObjectInfoParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// FullBearer Provided bearer token is final or gate should assemble it using signature.
	FullBearer *FullBearerToken `form:"fullBearer,omitempty" json:"fullBearer,omitempty"`

	// RangeOffset Range offset to start reading data.
	RangeOffset *int64 `form:"range-offset,omitempty" json:"range-offset,omitempty"`

	// RangeLength Length of data range.
	RangeLength *int64 `form:"range-length,omitempty" json:"range-length,omitempty"`

	// MaxPayloadSize Max payload size (in bytes) that can be included in the response.
	// If the actual size is greater than this params the payload won't be included in the response.
	MaxPayloadSize *int `form:"max-payload-size,omitempty" json:"max-payload-size,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// UploadContainerObjectMultipartBody defines parameters for UploadContainerObject.
type UploadContainerObjectMultipartBody struct {
	// Payload The file to upload.  If no file is present in this field, any other field name will be accepted, except for an empty one.
	Payload *openapi_types.File `json:"payload,omitempty"`
}

// UploadContainerObjectParams defines parameters for UploadContainerObject.
type UploadContainerObjectParams struct {
	// XAttributeFilename This attribute, in any combination of upper/lower case, will be added to the object as the `FileName` attribute. It will also be returned as the `FileName` attribute in GET/HEAD API calls for the object (/get/{containerId}/{objectId}) and the `name` in POST call search in a container (/objects/{containerId}/search).
	XAttributeFilename *string `json:"X-Attribute-Filename,omitempty"`

	// XAttributeFilepath This attribute, in any combination of upper/lower case, will be added to the object as the `FilePath` attribute. It will also be returned as the `FilePath` attribute in GET/HEAD API calls for the object (/get/{containerId}/{objectId}) or the `filePath` in POST call search in a container (/objects/{containerId}/search).
	XAttributeFilepath *string `json:"X-Attribute-Filepath,omitempty"`
}

// AuthJSONRequestBody defines body for Auth for application/json ContentType.
type AuthJSONRequestBody = AuthJSONBody

// PutObjectJSONRequestBody defines body for PutObject for application/json ContentType.
type PutObjectJSONRequestBody = ObjectUpload

// UploadContainerObjectMultipartRequestBody defines body for UploadContainerObject for multipart/form-data ContentType.
type UploadContainerObjectMultipartRequestBody UploadContainerObjectMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get balance in NeoFS
	// (GET /accounting/balance/{address})
	GetBalance(ctx echo.Context, address string) error

	// (OPTIONS /accounting/balance/{address})
	OptionsBalance(ctx echo.Context, address string) error

	// (OPTIONS /auth)
	OptionsAuth(ctx echo.Context) error
	// Form bearer token to further requests
	// (POST /auth)
	Auth(ctx echo.Context, params AuthParams) error
	// Form binary bearer token
	// (GET /auth/bearer)
	FormBinaryBearer(ctx echo.Context, params FormBinaryBearerParams) error

	// (OPTIONS /auth/bearer)
	OptionsAuthBearer(ctx echo.Context) error
	// Get list of containers
	// (GET /containers)
	ListContainers(ctx echo.Context, params ListContainersParams) error

	// (OPTIONS /containers)
	OptionsContainersPutList(ctx echo.Context) error
	// Create new container in NeoFS
	// (PUT /containers)
	PutContainer(ctx echo.Context, params PutContainerParams) error
	// Delete container by id
	// (DELETE /containers/{containerId})
	DeleteContainer(ctx echo.Context, containerId ContainerId, params DeleteContainerParams) error
	// Get container by id
	// (GET /containers/{containerId})
	GetContainer(ctx echo.Context, containerId ContainerId) error

	// (OPTIONS /containers/{containerId})
	OptionsContainersGetDelete(ctx echo.Context, containerId ContainerId) error
	// Get container EACL by id
	// (GET /containers/{containerId}/eacl)
	GetContainerEACL(ctx echo.Context, containerId ContainerId) error

	// (OPTIONS /containers/{containerId}/eacl)
	OptionsContainersEACL(ctx echo.Context, containerId ContainerId) error
	// Set container EACL by id
	// (PUT /containers/{containerId}/eacl)
	PutContainerEACL(ctx echo.Context, containerId ContainerId, params PutContainerEACLParams) error
	// Get object by container ID and object ID. Also returns custom users' header attributes `X-Attribute-*`. It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section.
	// (GET /get/{containerId}/{objectId})
	GetContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params GetContainerObjectParams) error
	// Get object info (head) by container ID and object ID. Also returns custom users' header attributes `X-Attribute-*`.
	// (HEAD /get/{containerId}/{objectId})
	HeadContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params HeadContainerObjectParams) error

	// (OPTIONS /get/{containerId}/{objectId})
	OptionsContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId) error
	// Find and get an object (payload and attributes) by a specific attribute. If more than one object is found, an arbitrary one will be returned. It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section.
	// (GET /get_by_attribute/{containerId}/{attrKey}/{attrVal})
	GetByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params GetByAttributeParams) error
	// Get object attributes by a specific attribute. If more than one object is found, an arbitrary one will be used to get attributes.
	// (HEAD /get_by_attribute/{containerId}/{attrKey}/{attrVal})
	HeadByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params HeadByAttributeParams) error

	// (OPTIONS /get_by_attribute/{containerId}/{attrKey}/{attrVal})
	OptionsByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal) error

	// (OPTIONS /objects)
	OptionsObjectsPut(ctx echo.Context) error
	// Upload object to NeoFS
	// (PUT /objects)
	PutObject(ctx echo.Context, params PutObjectParams) error

	// (OPTIONS /objects/{containerId}/search)
	OptionsObjectsSearch(ctx echo.Context, containerId string) error
	// Search objects by filters
	// (POST /objects/{containerId}/search)
	SearchObjects(ctx echo.Context, containerId ContainerId, params SearchObjectsParams) error
	// Remove object from NeoFS
	// (DELETE /objects/{containerId}/{objectId})
	DeleteObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params DeleteObjectParams) error
	// Get object info by address
	// (GET /objects/{containerId}/{objectId})
	GetObjectInfo(ctx echo.Context, containerId ContainerId, objectId ObjectId, params GetObjectInfoParams) error

	// (OPTIONS /objects/{containerId}/{objectId})
	OptionsObjectsGetDelete(ctx echo.Context, containerId ContainerId, objectId ObjectId) error

	// (OPTIONS /upload/{containerId})
	OptionsUploadContainerObject(ctx echo.Context, containerId ContainerId) error
	// Upload object to NeoFS
	// (POST /upload/{containerId})
	UploadContainerObject(ctx echo.Context, containerId ContainerId, params UploadContainerObjectParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBalance(ctx, address)
	return err
}

// OptionsBalance converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsBalance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsBalance(ctx, address)
	return err
}

// OptionsAuth converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsAuth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsAuth(ctx)
	return err
}

// Auth converts echo context to params.
func (w *ServerInterfaceWrapper) Auth(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Bearer-Owner-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Owner-Id")]; found {
		var XBearerOwnerId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Owner-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Owner-Id", valueList[0], &XBearerOwnerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Owner-Id: %s", err))
		}

		params.XBearerOwnerId = XBearerOwnerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Bearer-Owner-Id is required, but not found"))
	}
	// ------------- Optional header parameter "X-Bearer-Lifetime" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Lifetime")]; found {
		var XBearerLifetime int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Lifetime, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Lifetime", valueList[0], &XBearerLifetime, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Lifetime: %s", err))
		}

		params.XBearerLifetime = &XBearerLifetime
	}
	// ------------- Optional header parameter "X-Bearer-For-All-Users" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-For-All-Users")]; found {
		var XBearerForAllUsers bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-For-All-Users, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-For-All-Users", valueList[0], &XBearerForAllUsers, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-For-All-Users: %s", err))
		}

		params.XBearerForAllUsers = &XBearerForAllUsers
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Auth(ctx, params)
	return err
}

// FormBinaryBearer converts echo context to params.
func (w *ServerInterfaceWrapper) FormBinaryBearer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FormBinaryBearerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FormBinaryBearer(ctx, params)
	return err
}

// OptionsAuthBearer converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsAuthBearer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsAuthBearer(ctx)
	return err
}

// ListContainers converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListContainersParams
	// ------------- Required query parameter "ownerId" -------------

	err = runtime.BindQueryParameter("form", true, true, "ownerId", ctx.QueryParams(), &params.OwnerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ownerId: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainers(ctx, params)
	return err
}

// OptionsContainersPutList converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersPutList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersPutList(ctx)
	return err
}

// PutContainer converts echo context to params.
func (w *ServerInterfaceWrapper) PutContainer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "name-scope-global" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-scope-global", ctx.QueryParams(), &params.NameScopeGlobal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name-scope-global: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutContainer(ctx, params)
	return err
}

// DeleteContainer converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteContainer(ctx, containerId, params)
	return err
}

// GetContainer converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainer(ctx, containerId)
	return err
}

// OptionsContainersGetDelete converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersGetDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersGetDelete(ctx, containerId)
	return err
}

// GetContainerEACL converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerEACL(ctx, containerId)
	return err
}

// OptionsContainersEACL converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersEACL(ctx, containerId)
	return err
}

// PutContainerEACL converts echo context to params.
func (w *ServerInterfaceWrapper) PutContainerEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutContainerEACLParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutContainerEACL(ctx, containerId, params)
	return err
}

// GetContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContainerObjectParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerObject(ctx, containerId, objectId, params)
	return err
}

// HeadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) HeadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadContainerObjectParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HeadContainerObject(ctx, containerId, objectId, params)
	return err
}

// OptionsContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainerObject(ctx, containerId, objectId)
	return err
}

// GetByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) GetByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetByAttributeParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// HeadByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) HeadByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadByAttributeParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HeadByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// OptionsByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsByAttribute(ctx, containerId, attrKey, attrVal)
	return err
}

// OptionsObjectsPut converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsPut(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsPut(ctx)
	return err
}

// PutObject converts echo context to params.
func (w *ServerInterfaceWrapper) PutObject(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "fullBearer" -------------

	err = runtime.BindQueryParameter("form", true, false, "fullBearer", ctx.QueryParams(), &params.FullBearer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fullBearer: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutObject(ctx, params)
	return err
}

// OptionsObjectsSearch converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsSearch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId string

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsSearch(ctx, containerId)
	return err
}

// SearchObjects converts echo context to params.
func (w *ServerInterfaceWrapper) SearchObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchObjectsParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "fullBearer" -------------

	err = runtime.BindQueryParameter("form", true, false, "fullBearer", ctx.QueryParams(), &params.FullBearer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fullBearer: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchObjects(ctx, containerId, params)
	return err
}

// DeleteObject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "fullBearer" -------------

	err = runtime.BindQueryParameter("form", true, false, "fullBearer", ctx.QueryParams(), &params.FullBearer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fullBearer: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteObject(ctx, containerId, objectId, params)
	return err
}

// GetObjectInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetObjectInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectInfoParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "fullBearer" -------------

	err = runtime.BindQueryParameter("form", true, false, "fullBearer", ctx.QueryParams(), &params.FullBearer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fullBearer: %s", err))
	}

	// ------------- Optional query parameter "range-offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "range-offset", ctx.QueryParams(), &params.RangeOffset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter range-offset: %s", err))
	}

	// ------------- Optional query parameter "range-length" -------------

	err = runtime.BindQueryParameter("form", true, false, "range-length", ctx.QueryParams(), &params.RangeLength)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter range-length: %s", err))
	}

	// ------------- Optional query parameter "max-payload-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-payload-size", ctx.QueryParams(), &params.MaxPayloadSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-payload-size: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetObjectInfo(ctx, containerId, objectId, params)
	return err
}

// OptionsObjectsGetDelete converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsGetDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsGetDelete(ctx, containerId, objectId)
	return err
}

// OptionsUploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsUploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsUploadContainerObject(ctx, containerId)
	return err
}

// UploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) UploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadContainerObjectParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Attribute-Filename" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Attribute-Filename")]; found {
		var XAttributeFilename string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Attribute-Filename, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Attribute-Filename", valueList[0], &XAttributeFilename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Attribute-Filename: %s", err))
		}

		params.XAttributeFilename = &XAttributeFilename
	}
	// ------------- Optional header parameter "X-Attribute-Filepath" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Attribute-Filepath")]; found {
		var XAttributeFilepath string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Attribute-Filepath, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Attribute-Filepath", valueList[0], &XAttributeFilepath, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Attribute-Filepath: %s", err))
		}

		params.XAttributeFilepath = &XAttributeFilepath
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadContainerObject(ctx, containerId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/accounting/balance/:address", wrapper.GetBalance)
	router.OPTIONS(baseURL+"/accounting/balance/:address", wrapper.OptionsBalance)
	router.OPTIONS(baseURL+"/auth", wrapper.OptionsAuth)
	router.POST(baseURL+"/auth", wrapper.Auth)
	router.GET(baseURL+"/auth/bearer", wrapper.FormBinaryBearer)
	router.OPTIONS(baseURL+"/auth/bearer", wrapper.OptionsAuthBearer)
	router.GET(baseURL+"/containers", wrapper.ListContainers)
	router.OPTIONS(baseURL+"/containers", wrapper.OptionsContainersPutList)
	router.PUT(baseURL+"/containers", wrapper.PutContainer)
	router.DELETE(baseURL+"/containers/:containerId", wrapper.DeleteContainer)
	router.GET(baseURL+"/containers/:containerId", wrapper.GetContainer)
	router.OPTIONS(baseURL+"/containers/:containerId", wrapper.OptionsContainersGetDelete)
	router.GET(baseURL+"/containers/:containerId/eacl", wrapper.GetContainerEACL)
	router.OPTIONS(baseURL+"/containers/:containerId/eacl", wrapper.OptionsContainersEACL)
	router.PUT(baseURL+"/containers/:containerId/eacl", wrapper.PutContainerEACL)
	router.GET(baseURL+"/get/:containerId/:objectId", wrapper.GetContainerObject)
	router.HEAD(baseURL+"/get/:containerId/:objectId", wrapper.HeadContainerObject)
	router.OPTIONS(baseURL+"/get/:containerId/:objectId", wrapper.OptionsContainerObject)
	router.GET(baseURL+"/get_by_attribute/:containerId/:attrKey/:attrVal", wrapper.GetByAttribute)
	router.HEAD(baseURL+"/get_by_attribute/:containerId/:attrKey/:attrVal", wrapper.HeadByAttribute)
	router.OPTIONS(baseURL+"/get_by_attribute/:containerId/:attrKey/:attrVal", wrapper.OptionsByAttribute)
	router.OPTIONS(baseURL+"/objects", wrapper.OptionsObjectsPut)
	router.PUT(baseURL+"/objects", wrapper.PutObject)
	router.OPTIONS(baseURL+"/objects/:containerId/search", wrapper.OptionsObjectsSearch)
	router.POST(baseURL+"/objects/:containerId/search", wrapper.SearchObjects)
	router.DELETE(baseURL+"/objects/:containerId/:objectId", wrapper.DeleteObject)
	router.GET(baseURL+"/objects/:containerId/:objectId", wrapper.GetObjectInfo)
	router.OPTIONS(baseURL+"/objects/:containerId/:objectId", wrapper.OptionsObjectsGetDelete)
	router.OPTIONS(baseURL+"/upload/:containerId", wrapper.OptionsUploadContainerObject)
	router.POST(baseURL+"/upload/:containerId", wrapper.UploadContainerObject)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
