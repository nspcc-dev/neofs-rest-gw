// Package apiserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package apiserver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
	CookieAuthScopes = "CookieAuth.Scopes"
)

// Defines values for Action.
const (
	ALLOW Action = "ALLOW"
	DENY  Action = "DENY"
)

// Defines values for ErrorType.
const (
	API ErrorType = "API"
	GW  ErrorType = "GW"
)

// Defines values for HeaderType.
const (
	OBJECT  HeaderType = "OBJECT"
	REQUEST HeaderType = "REQUEST"
	SERVICE HeaderType = "SERVICE"
)

// Defines values for MatchType.
const (
	STRINGEQUAL    MatchType = "STRING_EQUAL"
	STRINGNOTEQUAL MatchType = "STRING_NOT_EQUAL"
)

// Defines values for Operation.
const (
	OperationDELETE    Operation = "DELETE"
	OperationGET       Operation = "GET"
	OperationHEAD      Operation = "HEAD"
	OperationPUT       Operation = "PUT"
	OperationRANGE     Operation = "RANGE"
	OperationRANGEHASH Operation = "RANGEHASH"
	OperationSEARCH    Operation = "SEARCH"
)

// Defines values for Role.
const (
	KEYS   Role = "KEYS"
	OTHERS Role = "OTHERS"
	SYSTEM Role = "SYSTEM"
	USER   Role = "USER"
)

// Defines values for SchemaType.
const (
	DETERMINISTICSHA256 SchemaType = "DETERMINISTIC_SHA256"
	N3                  SchemaType = "N3"
	SHA512              SchemaType = "SHA512"
	WALLETCONNECT       SchemaType = "WALLETCONNECT"
)

// Defines values for SearchMatch.
const (
	MatchCommonPrefix   SearchMatch = "MatchCommonPrefix"
	MatchNotPresent     SearchMatch = "MatchNotPresent"
	MatchNumGE          SearchMatch = "MatchNumGE"
	MatchNumGT          SearchMatch = "MatchNumGT"
	MatchNumLE          SearchMatch = "MatchNumLE"
	MatchNumLT          SearchMatch = "MatchNumLT"
	MatchStringEqual    SearchMatch = "MatchStringEqual"
	MatchStringNotEqual SearchMatch = "MatchStringNotEqual"
)

// Defines values for TokenType.
const (
	Container TokenType = "container"
	Object    TokenType = "object"
)

// Defines values for TokenVerb.
const (
	CONTAINERDELETE          TokenVerb = "CONTAINER_DELETE"
	CONTAINERPUT             TokenVerb = "CONTAINER_PUT"
	CONTAINERREMOVEATTRIBUTE TokenVerb = "CONTAINER_REMOVE_ATTRIBUTE"
	CONTAINERSETATTRIBUTE    TokenVerb = "CONTAINER_SET_ATTRIBUTE"
	CONTAINERSETEACL         TokenVerb = "CONTAINER_SET_EACL"
	OBJECTDELETE             TokenVerb = "OBJECT_DELETE"
	OBJECTGET                TokenVerb = "OBJECT_GET"
	OBJECTHEAD               TokenVerb = "OBJECT_HEAD"
	OBJECTPUT                TokenVerb = "OBJECT_PUT"
	OBJECTRANGE              TokenVerb = "OBJECT_RANGE"
	OBJECTRANGEHASH          TokenVerb = "OBJECT_RANGE_HASH"
	OBJECTSEARCH             TokenVerb = "OBJECT_SEARCH"
)

// Defines values for Verb.
const (
	VerbDELETE  Verb = "DELETE"
	VerbPUT     Verb = "PUT"
	VerbSETEACL Verb = "SETEACL"
)

// Action Rule execution result action in NeoFS EACL. Either allows or denies access if the rule's filters match.
type Action string

// Address Address of the object in NeoFS.
type Address struct {
	ContainerId string `json:"containerId"`
	ObjectId    string `json:"objectId"`
}

// AddressForUpload Address of the object in NeoFS.
type AddressForUpload struct {
	ContainerId string `json:"container_id"`
	ObjectId    string `json:"object_id"`
}

// Attribute Attribute is a pair of strings that can be attached to a container or an object.
type Attribute struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Balance defines model for Balance.
type Balance struct {
	Address   string `json:"address"`
	Precision uint32 `json:"precision"`
	Value     string `json:"value"`
}

// Bearer defines model for Bearer.
type Bearer struct {
	// Container Container session token rule.
	Container *Rule    `json:"container,omitempty"`
	Name      string   `json:"name,omitempty"`
	Object    []Record `json:"object"`
}

// BinaryBearer Bearer token for object operations that is represented in binary form.
type BinaryBearer struct {
	// Token Base64 encoded bearer token.
	Token string `json:"token"`
}

// BinarySessionV2 Session v2 token for operations. form.
type BinarySessionV2 struct {
	// Token Base64 encoded session v2 token.
	Token string `json:"token"`
}

// CompleteSessionTokenV2Request The unsigned Session Token v2, its associated signature, and the public component of the signing key.
type CompleteSessionTokenV2Request struct {
	// Key If scheme is not N3, Hex encoded public part of the key that signed the session token. If scheme N3, Base64 encoded verifScript.
	Key string `json:"key"`

	// Scheme Signature scheme type for a session token.
	Scheme SchemaType `json:"scheme"`

	// Token Base64 encoded unsigned session v2 token.
	Token string `json:"token"`

	// Value If scheme is not N3, Base64 encoded signature for session v2 token. If scheme N3, Base64 encoded invocScript.
	Value string `json:"value"`
}

// ContainerInfo Information about container.
type ContainerInfo struct {
	Attributes []Attribute `json:"attributes"`
	BasicAcl   string      `json:"basicAcl"`

	// CannedAcl The friendly name for the basicAcl field.
	CannedAcl       *string `json:"cannedAcl,omitempty"`
	ContainerId     string  `json:"containerId"`
	ContainerName   string  `json:"containerName"`
	OwnerId         string  `json:"ownerId"`
	PlacementPolicy string  `json:"placementPolicy"`
	Version         string  `json:"version"`
}

// ContainerList List of containers info
type ContainerList struct {
	Containers []ContainerInfo `json:"containers"`
	Size       int             `json:"size"`
}

// ContainerPostInfo <p>Request body to create container. To specify container name use appropriate property (name provided in attributes will be ignored).<p>
// <p>To create a container you must provide <code>PlacementPolicy</code> and <code>BasicACL</code>.</p>
//
// <h5>Placement policy</h5>
// <p>Placement policy allows you control where and how the container (and its object) is stored. For example, you want to store 3 copies of every object, so you can use the following policy:</p>
// <pre><code>REP 3</code></pre>
// <p><a href="https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/02-policy.md">More about policy</a>.</p>
//
// <h5>Basic ACL</h5>
// <p>Basic ACL is a part of the container structure, and it is always created simultaneously with the container. Therefore, it is never subject to any changes. It is a 32-bit integer with a bit field in the following format:</p>
// <p><img src="https://raw.githubusercontent.com/nspcc-dev/neofs-spec/046e623dc2d8134ab2b85fcaf831077d574561a2/01-arch/pic/acl-basic-private.svg" alt="ACL Basic"></p>
//
// <table>
//
//	<thead>
//	    <tr>
//	        <th>Symbol</th>
//	        <th>Meaning</th>
//	        <th>Description</th>
//	    </tr>
//	</thead>
//	<tbody>
//	    <tr>
//	        <td>B</td>
//	        <td>Bearer</td>
//	        <td>Allows using Bear Token ACL rules to replace eACL rules</td>
//	    </tr>
//	    <tr>
//	        <td>U</td>
//	        <td>User</td>
//	        <td>The owner of the container identified by the public key linked to the container</td>
//	    </tr>
//	    <tr>
//	        <td>S</td>
//	        <td>System</td>
//	        <td>Inner Ring and/or container nodes in the current version of network map. IR nodes can only perform <code>GetRangeHash</code>, <code>Head</code>, and <code>Search</code> necessary for data audit. Container nodes can only do things required for the replication.</td>
//	    </tr>
//	    <tr>
//	        <td>O</td>
//	        <td>Others</td>
//	        <td>Clients that do not match any of the categories above</td>
//	    </tr>
//	    <tr>
//	        <td>F</td>
//	        <td>Final</td>
//	        <td>Flag denying Extended ACL. If set, Basic ACL check is final, Extended ACL is ignored</td>
//	    </tr>
//	    <tr>
//	        <td>X</td>
//	        <td>Sticky</td>
//	        <td>Flag denying different owners of the request and the object. If set, object in <code>Put</code> request must have one <code>Owner</code> and be signed with the same signature. If not set, the object must be correct but can be of any owner. The nodes falling for <code>SYSTEM</code> role are exceptions from this rule. For them, the bit is ignored.</td>
//	    </tr>
//	    <tr>
//	        <td>0</td>
//	        <td>Deny</td>
//	        <td>Denies operation of the identified category</td>
//	    </tr>
//	    <tr>
//	        <td>1</td>
//	        <td>Allow</td>
//	        <td>Allows operation of the identified category</td>
//	    </tr>
//	</tbody>
//
// </table>
// <p>To upload objects with a bearer token your container must have Bearer bits set. For example, you can use <code>0x0FBFBFFF</code> or predefined <code>eacl-public-read-write</code> values.</p>
// <p>Also, don't forget to set appropriate eACL to restrict your container.</p>
// <p><a href="https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/07-acl.md">More about ACL</a>.</p>
type ContainerPostInfo struct {
	Attributes      []Attribute `json:"attributes,omitempty"`
	BasicAcl        string      `json:"basicAcl,omitempty"`
	ContainerName   string      `json:"containerName,omitempty"`
	PlacementPolicy string      `json:"placementPolicy,omitempty"`
}

// Eacl EACL NeoFS table.
type Eacl struct {
	ContainerId string   `json:"containerId"`
	Records     []Record `json:"records"`
}

// ErrorResponse <p>Error response.</p>
// <p>More about NeoFS status code you can find
//
//	<a href="https://github.com/nspcc-dev/neofs-spec/blob/master/20-api-v2/status.md">here</a>.</p>
type ErrorResponse struct {
	Code    uint32 `json:"code,omitempty"`
	Message string `json:"message"`

	// Type Error type. Allow determine source of the error.
	Type ErrorType `json:"type"`
}

// ErrorType Error type. Allow determine source of the error.
type ErrorType string

// Filter Filter in NeoFS EACL to check particular properties of the request or the object.
type Filter struct {
	// HeaderType Enumeration of possible sources of Headers to apply filters in NeoFS EACL.
	HeaderType HeaderType `json:"headerType"`
	Key        string     `json:"key"`

	// MatchType Match type in NeoFS EACL filter.
	MatchType MatchType `json:"matchType"`
	Value     string    `json:"value"`
}

// FormBearerRequest Bearer token that is expected to be formed.
type FormBearerRequest struct {
	Records []Record `json:"records"`
}

// FormBearerResponse Bearer token that is expected to be formed.
type FormBearerResponse struct {
	// Token Base64 encoded unsigned bearer token.
	Token string `json:"token"`
}

// GatewayMetadataResponse defines model for GatewayMetadataResponse.
type GatewayMetadataResponse struct {
	Address string  `json:"address"`
	NnsName *string `json:"nns_name,omitempty"`
}

// HeaderType Enumeration of possible sources of Headers to apply filters in NeoFS EACL.
type HeaderType string

// MatchType Match type in NeoFS EACL filter.
type MatchType string

// NetworkInfoOK Network information from NeoFS.
type NetworkInfoOK struct {
	AuditFee                   uint64 `json:"auditFee"`
	ContainerFee               uint64 `json:"containerFee"`
	EpochDuration              uint64 `json:"epochDuration"`
	HomomorphicHashingDisabled bool   `json:"homomorphicHashingDisabled"`
	MaxObjectSize              uint64 `json:"maxObjectSize"`
	NamedContainerFee          uint64 `json:"namedContainerFee"`
	StoragePrice               uint64 `json:"storagePrice"`
	WithdrawalFee              uint64 `json:"withdrawalFee"`
}

// ObjectBaseInfo Basic object information.
type ObjectBaseInfo struct {
	// Address Address of the object in NeoFS.
	Address  Address `json:"address"`
	FilePath *string `json:"filePath,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// ObjectBaseInfoV2 Basic object information.
type ObjectBaseInfoV2 struct {
	Attributes map[string]interface{} `json:"attributes"`
	ObjectId   string                 `json:"objectId"`
}

// ObjectList List of objects.
type ObjectList struct {
	Objects []ObjectBaseInfo `json:"objects"`
	Size    int              `json:"size"`
}

// ObjectListV2 List of objects.
type ObjectListV2 struct {
	// Cursor Value to start the next batch from.
	Cursor string `json:"cursor"`

	// Incomplete If true, it describes incomplete success. The search has been done, but not all nodes returned the result, so it may be missing some items.
	Incomplete *bool              `json:"incomplete,omitempty"`
	Objects    []ObjectBaseInfoV2 `json:"objects"`
}

// Operation Request's operation type to match in NeoFS EACL if the rule is applicable to a particular request.
type Operation string

// PostContainerOK defines model for PostContainerOK.
type PostContainerOK struct {
	ContainerId string `json:"containerId"`
}

// Record A single NeoFS EACL rule.
type Record struct {
	// Action Rule execution result action in NeoFS EACL. Either allows or denies access if the rule's filters match.
	Action  Action   `json:"action"`
	Filters []Filter `json:"filters"`

	// Operation Request's operation type to match in NeoFS EACL if the rule is applicable to a particular request.
	Operation Operation `json:"operation"`
	Targets   []Target  `json:"targets"`
}

// Role Role for target in EACL.
type Role string

// Rule Container session token rule.
type Rule struct {
	ContainerId *string `json:"containerId,omitempty"`

	// Verb Verb that describes the allowed container operation for token.
	Verb Verb `json:"verb"`
}

// SchemaType Signature scheme type for a session token.
type SchemaType string

// SearchFilter Search filter to find objects.
type SearchFilter struct {
	// Key For special `$Object:ROOT` and `$Object:PHY` filters value and match are ignored, other object header filters are supported normally.
	Key string `json:"key"`

	// Match Search match type.
	Match SearchMatch `json:"match"`

	// Value Numeric filters MatchNumGT, MatchNumGE, MatchNumLT, MatchNumLE can be in range [-2^255, 2^255 -1].
	Value string `json:"value"`
}

// SearchFilters List of SearchFilter elements.
type SearchFilters struct {
	// Filters It must contain 7 filters as maximum.
	Filters []SearchFilter `json:"filters"`
}

// SearchMatch Search match type.
type SearchMatch string

// SearchRequest List of SearchFilter elements.
type SearchRequest struct {
	// Attributes Attribute list to be returned for each object. It must contain 7 attributes as maximum.
	Attributes []string `json:"attributes"`

	// Filters It must contain 7 filters as maximum.
	Filters []SearchFilter `json:"filters"`
}

// SessionTokenV2Request Session token v2 that is expected to be formed.
type SessionTokenV2Request struct {
	// Contexts The session token contexts.
	Contexts []TokenContext `json:"contexts"`

	// ExpirationDuration Specifies the duration until object expiration in Go's duration format. Examples:
	//   - "300s" represents 5 minutes.
	//   - "2h45m" represents 2 hours and 45 minutes.
	ExpirationDuration string `json:"expiration-duration,omitempty"`

	// ExpirationRfc3339 Specifies the expiration time in RFC3339 format. Examples:
	// - "2024-12-31T23:59:59Z" represents the last moment of 2024 in UTC.
	// - "2024-12-31T15:59:59-08:00" represents 3:59 PM on December 31, 2024, Pacific Time.
	ExpirationRfc3339 string `json:"expiration-rfc3339,omitempty"`

	// Final If true, preventing further delegations.
	Final bool `json:"final,omitempty"`

	// Origin If passed, sets the origin token for delegation chain. Base64 encoded.
	Origin string `json:"origin,omitempty"`

	// Owner Token issuer ID (account address).
	Owner string `json:"owner"`

	// Targets The accounts authorized (owners) by this token.
	Targets []string `json:"targets"`
}

// SessionTokenv2Response defines model for SessionTokenv2Response.
type SessionTokenv2Response struct {
	// Token Base64 encoded unsigned token, what should be signed.
	Token string `json:"token,omitempty"`
}

// SuccessResponse Success response.
type SuccessResponse struct {
	Success bool `json:"success"`
}

// Target Target to apply the ACL rule. Can be a subject's role class or a list of public keys to match (KEYS role).
type Target struct {
	Keys []string `json:"keys"`

	// Role Role for target in EACL.
	Role Role `json:"role"`
}

// TokenContext defines model for TokenContext.
type TokenContext struct {
	// ContainerID If set, narrows the session token to this container id. Container can be zero (wildcard).
	ContainerID string      `json:"containerID,omitempty"`
	Verbs       []TokenVerb `json:"verbs,omitempty"`
}

// TokenResponse Base64 encoded marshaled token (for container or for object operations).
type TokenResponse struct {
	Name  *string `json:"name,omitempty"`
	Token string  `json:"token"`

	// Type Type of token.
	Type TokenType `json:"type"`
}

// TokenType Type of token.
type TokenType string

// TokenVerb Verb that describes the allowed operations for token.
type TokenVerb string

// Verb Verb that describes the allowed container operation for token.
type Verb string

// AttrKey defines model for attrKey.
type AttrKey = string

// AttrVal defines model for attrVal.
type AttrVal = string

// ContainerId defines model for containerId.
type ContainerId = string

// ObjectId defines model for objectId.
type ObjectId = string

// Range defines model for range.
type Range = string

// SessionToken defines model for sessionToken.
type SessionToken = string

// SignatureKeyParam defines model for signatureKeyParam.
type SignatureKeyParam = string

// SignatureParam defines model for signatureParam.
type SignatureParam = string

// SignatureScheme defines model for signatureScheme.
type SignatureScheme = bool

// AuthJSONBody defines parameters for Auth.
type AuthJSONBody = []Bearer

// AuthParams defines parameters for Auth.
type AuthParams struct {
	// XBearerOwnerId Owner Id (wallet address) that will sign the token.
	XBearerOwnerId string `json:"X-Bearer-Owner-Id"`

	// XBearerLifetime Token lifetime in epoch.
	XBearerLifetime *int `json:"X-Bearer-Lifetime,omitempty"`

	// XBearerForAllUsers Form token for all users or only for this gate.
	XBearerForAllUsers *bool `json:"X-Bearer-For-All-Users,omitempty"`
}

// FormBinaryBearerParams defines parameters for FormBinaryBearer.
type FormBinaryBearerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// ListContainersParams defines parameters for ListContainers.
type ListContainersParams struct {
	// OwnerId Base58 encoded owner id.
	OwnerId string `form:"ownerId" json:"ownerId"`

	// Offset The number of containers to skip before starting to collect the result set.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of containers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostContainerParams defines parameters for PostContainer.
type PostContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// NameScopeGlobal Provide this parameter to register container name in NNS service.
	NameScopeGlobal *bool `form:"name-scope-global,omitempty" json:"name-scope-global,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// PutContainerParams defines parameters for PutContainer.
type PutContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// NameScopeGlobal Provide this parameter to register container name in NNS service.
	NameScopeGlobal *bool `form:"name-scope-global,omitempty" json:"name-scope-global,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// DeleteContainerParams defines parameters for DeleteContainer.
type DeleteContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// PutContainerEACLParams defines parameters for PutContainerEACL.
type PutContainerEACLParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewOptionsUploadContainerObjectParams defines parameters for NewOptionsUploadContainerObject.
type NewOptionsUploadContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewUploadContainerObjectParams defines parameters for NewUploadContainerObject.
type NewUploadContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`

	// XAttributes All attributes are in a JSON-formatted map of key-value pairs, where the key is the
	// attribute name and the value is the attribute value.
	// You can also use the special attribute:
	// - `__NEOFS__EXPIRATION_EPOCH` - specifies the expiration epoch used by NeoFS.
	// This attribute should be used if you are familiar with the NeoFS epoch system.
	// More information can be found here: [NeoFS Specifications](https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/01-netmap.md).
	// Instead of this attribute you can use one of `X-Neofs-Expiration-*` headers below.
	XAttributes *string `json:"X-Attributes,omitempty"`

	// XNeofsExpirationRFC3339 Specifies the expiration time in RFC3339 format. Examples:
	// - "2024-12-31T23:59:59Z" represents the last moment of 2024 in UTC.
	// - "2024-12-31T15:59:59-08:00" represents 3:59 PM on December 31, 2024, Pacific Time.\
	// It will be rounded to the next epoch and used to set the `__NEOFS__EXPIRATION_EPOCH`
	// attribute of the created object.
	XNeofsExpirationRFC3339 *string `json:"X-Neofs-Expiration-RFC3339,omitempty"`

	// XNeofsExpirationTimestamp Specifies the exact timestamp of object expiration. It will be rounded to the next epoch and stored in the `__NEOFS__EXPIRATION_EPOCH` attribute of the created object.
	XNeofsExpirationTimestamp *string `json:"X-Neofs-Expiration-Timestamp,omitempty"`

	// XNeofsExpirationDuration Specifies the duration until object expiration in Go's duration format. Examples:
	// - "300s" represents 5 minutes.
	// - "2h45m" represents 2 hours and 45 minutes. \
	// It will be rounded to the next epoch and used to set the `__NEOFS__EXPIRATION_EPOCH` attribute of the created object.
	XNeofsExpirationDuration *string `json:"X-Neofs-Expiration-Duration,omitempty"`
}

// NewGetByAttributeParams defines parameters for NewGetByAttribute.
type NewGetByAttributeParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// Range Request a specific range of bytes from the object.
	Range *Range `json:"Range,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// NewHeadByAttributeParams defines parameters for NewHeadByAttribute.
type NewHeadByAttributeParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// NewOptionsByAttributeParams defines parameters for NewOptionsByAttribute.
type NewOptionsByAttributeParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewGetContainerObjectParams defines parameters for NewGetContainerObject.
type NewGetContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// Range Request a specific range of bytes from the object.
	Range *Range `json:"Range,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// NewHeadContainerObjectParams defines parameters for NewHeadContainerObject.
type NewHeadContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// NewOptionsContainerObjectParams defines parameters for NewOptionsContainerObject.
type NewOptionsContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// SearchObjectsParams defines parameters for SearchObjects.
type SearchObjectsParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Offset The number of containers to skip before starting to collect the result set.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of containers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// UnsignedBearerTokenParams defines parameters for UnsignedBearerToken.
type UnsignedBearerTokenParams struct {
	// XBearerIssuerId Issuer Id (wallet address) that will sign the token.
	XBearerIssuerId string `json:"X-Bearer-Issuer-Id"`

	// XBearerLifetime Token lifetime in epoch.
	XBearerLifetime *int `json:"X-Bearer-Lifetime,omitempty"`

	// XBearerOwner If set, the account authorized by this token.
	XBearerOwner *string `json:"X-Bearer-Owner,omitempty"`
}

// V2SearchObjectsParams defines parameters for V2SearchObjects.
type V2SearchObjectsParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Cursor Value to start the next batch from. It returns the first elements batch if empty value passed. You should take `cursor` value from previous response to be able to list items.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The numbers of objects to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XSessionToken Base64 encoded, signed session v2 token.
	XSessionToken *SessionToken `json:"X-Session-Token,omitempty"`
}

// AuthJSONRequestBody defines body for Auth for application/json ContentType.
type AuthJSONRequestBody = AuthJSONBody

// UnsignedBearerTokenJSONRequestBody defines body for UnsignedBearerToken for application/json ContentType.
type UnsignedBearerTokenJSONRequestBody = FormBearerRequest

// V2AuthSessionTokenJSONRequestBody defines body for V2AuthSessionToken for application/json ContentType.
type V2AuthSessionTokenJSONRequestBody = SessionTokenV2Request

// V2CompleteAuthSessionTokenJSONRequestBody defines body for V2CompleteAuthSessionToken for application/json ContentType.
type V2CompleteAuthSessionTokenJSONRequestBody = CompleteSessionTokenV2Request

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get balance in NeoFS
	// (GET /v1/accounting/balance/{address})
	GetBalance(ctx echo.Context, address string) error

	// (OPTIONS /v1/accounting/balance/{address})
	OptionsBalance(ctx echo.Context, address string) error

	// (OPTIONS /v1/auth)
	OptionsAuth(ctx echo.Context) error
	// Form bearer token to further requests
	// (POST /v1/auth)
	Auth(ctx echo.Context, params AuthParams) error
	// Form binary bearer token
	// (GET /v1/auth/bearer)
	FormBinaryBearer(ctx echo.Context, params FormBinaryBearerParams) error

	// (OPTIONS /v1/auth/bearer)
	OptionsAuthBearer(ctx echo.Context) error
	// Get list of containers
	// (GET /v1/containers)
	ListContainers(ctx echo.Context, params ListContainersParams) error

	// (OPTIONS /v1/containers)
	OptionsContainersPutList(ctx echo.Context) error
	// Create new container in NeoFS
	// (POST /v1/containers)
	PostContainer(ctx echo.Context, params PostContainerParams) error
	// Create new container in NeoFS. Use POST method to create a container.
	// (PUT /v1/containers)
	PutContainer(ctx echo.Context, params PutContainerParams) error
	// Delete container by id
	// (DELETE /v1/containers/{containerId})
	DeleteContainer(ctx echo.Context, containerId ContainerId, params DeleteContainerParams) error
	// Get container by id
	// (GET /v1/containers/{containerId})
	GetContainer(ctx echo.Context, containerId ContainerId) error

	// (OPTIONS /v1/containers/{containerId})
	OptionsContainersGetDelete(ctx echo.Context, containerId ContainerId) error
	// Get container EACL by id
	// (GET /v1/containers/{containerId}/eacl)
	GetContainerEACL(ctx echo.Context, containerId ContainerId) error

	// (OPTIONS /v1/containers/{containerId}/eacl)
	OptionsContainersEACL(ctx echo.Context, containerId ContainerId) error
	// Set container EACL by id
	// (PUT /v1/containers/{containerId}/eacl)
	PutContainerEACL(ctx echo.Context, containerId ContainerId, params PutContainerEACLParams) error
	// Get gateway metadata
	// (GET /v1/gateway)
	GatewayMetadata(ctx echo.Context) error

	// (OPTIONS /v1/gateway)
	OptionsGatewayMetadata(ctx echo.Context) error
	// Get network settings
	// (GET /v1/network-info)
	GetNetworkInfo(ctx echo.Context) error

	// (OPTIONS /v1/network-info)
	OptionsNetworkInfo(ctx echo.Context) error

	// (OPTIONS /v1/objects/{containerId})
	NewOptionsUploadContainerObject(ctx echo.Context, containerId ContainerId, params NewOptionsUploadContainerObjectParams) error
	// Upload object to NeoFS
	// (POST /v1/objects/{containerId})
	NewUploadContainerObject(ctx echo.Context, containerId ContainerId, params NewUploadContainerObjectParams) error
	// Find and get an object (payload and attributes) by a specific attribute. If more than one object is found, the latest one (wrt `Timestamp` attribute) from the first 1000 of search results will be returned (use `/objects/{containerId}/search` API if this is not desired). It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section. Also, returns custom users' object attributes in header `X-Attributes`.
	// (GET /v1/objects/{containerId}/by_attribute/{attrKey}/{attrVal})
	NewGetByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params NewGetByAttributeParams) error
	// Get object attributes by a specific attribute. If more than one object is found, the latest one (wrt `Timestamp` attribute) from the first 1000 of  search results will be returned (use `/objects/{containerId}/search` API if this is not desired). Also, returns custom users' object attributes in header `X-Attributes`.
	// (HEAD /v1/objects/{containerId}/by_attribute/{attrKey}/{attrVal})
	NewHeadByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params NewHeadByAttributeParams) error

	// (OPTIONS /v1/objects/{containerId}/by_attribute/{attrKey}/{attrVal})
	NewOptionsByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params NewOptionsByAttributeParams) error
	// Get object by container ID and object ID. Also, returns custom users' object attributes in header `X-Attributes`. It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section.
	// (GET /v1/objects/{containerId}/by_id/{objectId})
	NewGetContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params NewGetContainerObjectParams) error
	// Get object info (head) by container ID and object ID. Also, returns custom users' object attributes in header `X-Attributes`.
	// (HEAD /v1/objects/{containerId}/by_id/{objectId})
	NewHeadContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params NewHeadContainerObjectParams) error

	// (OPTIONS /v1/objects/{containerId}/by_id/{objectId})
	NewOptionsContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params NewOptionsContainerObjectParams) error

	// (OPTIONS /v1/objects/{containerId}/search)
	OptionsObjectsSearch(ctx echo.Context, containerId string) error
	// Search objects by filters
	// (POST /v1/objects/{containerId}/search)
	SearchObjects(ctx echo.Context, containerId ContainerId, params SearchObjectsParams) error
	// Remove object from NeoFS
	// (DELETE /v1/objects/{containerId}/{objectId})
	DeleteObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params DeleteObjectParams) error

	// (OPTIONS /v1/objects/{containerId}/{objectId})
	OptionsObjectsGetDelete(ctx echo.Context, containerId ContainerId, objectId ObjectId) error

	// (OPTIONS /v2/auth/bearer)
	OptionsUnsignedBearerToken(ctx echo.Context) error
	// Form bearer token to subsequent requests.
	// (POST /v2/auth/bearer)
	UnsignedBearerToken(ctx echo.Context, params UnsignedBearerTokenParams) error

	// (OPTIONS /v2/auth/session)
	OptionsV2AuthSessionToken(ctx echo.Context) error
	// Form v2 session token to subsequent requests.
	// (POST /v2/auth/session)
	V2AuthSessionToken(ctx echo.Context) error

	// (OPTIONS /v2/auth/session/complete)
	OptionsV2FormAuthSessionToken(ctx echo.Context) error
	// Joining the binary Session v2 token along with its signature to prepare the session token for use.
	// (POST /v2/auth/session/complete)
	V2CompleteAuthSessionToken(ctx echo.Context) error

	// (OPTIONS /v2/objects/{containerId}/search)
	OptionsV2SearchObjects(ctx echo.Context, containerId string) error
	// Search objects by filters
	// (POST /v2/objects/{containerId}/search)
	V2SearchObjects(ctx echo.Context, containerId ContainerId, params V2SearchObjectsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBalance(ctx, address)
	return err
}

// OptionsBalance converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsBalance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsBalance(ctx, address)
	return err
}

// OptionsAuth converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsAuth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsAuth(ctx)
	return err
}

// Auth converts echo context to params.
func (w *ServerInterfaceWrapper) Auth(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Bearer-Owner-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Owner-Id")]; found {
		var XBearerOwnerId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Owner-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Owner-Id", valueList[0], &XBearerOwnerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Owner-Id: %s", err))
		}

		params.XBearerOwnerId = XBearerOwnerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Bearer-Owner-Id is required, but not found"))
	}
	// ------------- Optional header parameter "X-Bearer-Lifetime" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Lifetime")]; found {
		var XBearerLifetime int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Lifetime, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Lifetime", valueList[0], &XBearerLifetime, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Lifetime: %s", err))
		}

		params.XBearerLifetime = &XBearerLifetime
	}
	// ------------- Optional header parameter "X-Bearer-For-All-Users" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-For-All-Users")]; found {
		var XBearerForAllUsers bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-For-All-Users, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-For-All-Users", valueList[0], &XBearerForAllUsers, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-For-All-Users: %s", err))
		}

		params.XBearerForAllUsers = &XBearerForAllUsers
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Auth(ctx, params)
	return err
}

// FormBinaryBearer converts echo context to params.
func (w *ServerInterfaceWrapper) FormBinaryBearer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FormBinaryBearerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FormBinaryBearer(ctx, params)
	return err
}

// OptionsAuthBearer converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsAuthBearer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsAuthBearer(ctx)
	return err
}

// ListContainers converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListContainersParams
	// ------------- Required query parameter "ownerId" -------------

	err = runtime.BindQueryParameter("form", true, true, "ownerId", ctx.QueryParams(), &params.OwnerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ownerId: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainers(ctx, params)
	return err
}

// OptionsContainersPutList converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersPutList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersPutList(ctx)
	return err
}

// PostContainer converts echo context to params.
func (w *ServerInterfaceWrapper) PostContainer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "name-scope-global" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-scope-global", ctx.QueryParams(), &params.NameScopeGlobal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name-scope-global: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostContainer(ctx, params)
	return err
}

// PutContainer converts echo context to params.
func (w *ServerInterfaceWrapper) PutContainer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "name-scope-global" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-scope-global", ctx.QueryParams(), &params.NameScopeGlobal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name-scope-global: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutContainer(ctx, params)
	return err
}

// DeleteContainer converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteContainer(ctx, containerId, params)
	return err
}

// GetContainer converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainer(ctx, containerId)
	return err
}

// OptionsContainersGetDelete converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersGetDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersGetDelete(ctx, containerId)
	return err
}

// GetContainerEACL converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerEACL(ctx, containerId)
	return err
}

// OptionsContainersEACL converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersEACL(ctx, containerId)
	return err
}

// PutContainerEACL converts echo context to params.
func (w *ServerInterfaceWrapper) PutContainerEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutContainerEACLParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutContainerEACL(ctx, containerId, params)
	return err
}

// GatewayMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GatewayMetadata(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GatewayMetadata(ctx)
	return err
}

// OptionsGatewayMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsGatewayMetadata(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsGatewayMetadata(ctx)
	return err
}

// GetNetworkInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworkInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworkInfo(ctx)
	return err
}

// OptionsNetworkInfo converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsNetworkInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsNetworkInfo(ctx)
	return err
}

// NewOptionsUploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewOptionsUploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NewOptionsUploadContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewOptionsUploadContainerObject(ctx, containerId, params)
	return err
}

// NewUploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewUploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewUploadContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}
	// ------------- Optional header parameter "X-Attributes" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Attributes")]; found {
		var XAttributes string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Attributes, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Attributes", valueList[0], &XAttributes, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Attributes: %s", err))
		}

		params.XAttributes = &XAttributes
	}
	// ------------- Optional header parameter "X-Neofs-Expiration-RFC3339" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Neofs-Expiration-RFC3339")]; found {
		var XNeofsExpirationRFC3339 string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Neofs-Expiration-RFC3339, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Neofs-Expiration-RFC3339", valueList[0], &XNeofsExpirationRFC3339, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Neofs-Expiration-RFC3339: %s", err))
		}

		params.XNeofsExpirationRFC3339 = &XNeofsExpirationRFC3339
	}
	// ------------- Optional header parameter "X-Neofs-Expiration-Timestamp" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Neofs-Expiration-Timestamp")]; found {
		var XNeofsExpirationTimestamp string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Neofs-Expiration-Timestamp, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Neofs-Expiration-Timestamp", valueList[0], &XNeofsExpirationTimestamp, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Neofs-Expiration-Timestamp: %s", err))
		}

		params.XNeofsExpirationTimestamp = &XNeofsExpirationTimestamp
	}
	// ------------- Optional header parameter "X-Neofs-Expiration-Duration" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Neofs-Expiration-Duration")]; found {
		var XNeofsExpirationDuration string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Neofs-Expiration-Duration, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Neofs-Expiration-Duration", valueList[0], &XNeofsExpirationDuration, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Neofs-Expiration-Duration: %s", err))
		}

		params.XNeofsExpirationDuration = &XNeofsExpirationDuration
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewUploadContainerObject(ctx, containerId, params)
	return err
}

// NewGetByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) NewGetByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewGetByAttributeParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range Range
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Range, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Range: %s", err))
		}

		params.Range = &Range
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewGetByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// NewHeadByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) NewHeadByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewHeadByAttributeParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewHeadByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// NewOptionsByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) NewOptionsByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NewOptionsByAttributeParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewOptionsByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// NewGetContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewGetContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewGetContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range Range
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Range, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Range: %s", err))
		}

		params.Range = &Range
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewGetContainerObject(ctx, containerId, objectId, params)
	return err
}

// NewHeadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewHeadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewHeadContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewHeadContainerObject(ctx, containerId, objectId, params)
	return err
}

// NewOptionsContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewOptionsContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NewOptionsContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewOptionsContainerObject(ctx, containerId, objectId, params)
	return err
}

// OptionsObjectsSearch converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsSearch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId string

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsSearch(ctx, containerId)
	return err
}

// SearchObjects converts echo context to params.
func (w *ServerInterfaceWrapper) SearchObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchObjectsParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchObjects(ctx, containerId, params)
	return err
}

// DeleteObject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteObject(ctx, containerId, objectId, params)
	return err
}

// OptionsObjectsGetDelete converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsGetDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsGetDelete(ctx, containerId, objectId)
	return err
}

// OptionsUnsignedBearerToken converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsUnsignedBearerToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsUnsignedBearerToken(ctx)
	return err
}

// UnsignedBearerToken converts echo context to params.
func (w *ServerInterfaceWrapper) UnsignedBearerToken(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UnsignedBearerTokenParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Bearer-Issuer-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Issuer-Id")]; found {
		var XBearerIssuerId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Issuer-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Issuer-Id", valueList[0], &XBearerIssuerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Issuer-Id: %s", err))
		}

		params.XBearerIssuerId = XBearerIssuerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Bearer-Issuer-Id is required, but not found"))
	}
	// ------------- Optional header parameter "X-Bearer-Lifetime" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Lifetime")]; found {
		var XBearerLifetime int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Lifetime, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Lifetime", valueList[0], &XBearerLifetime, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Lifetime: %s", err))
		}

		params.XBearerLifetime = &XBearerLifetime
	}
	// ------------- Optional header parameter "X-Bearer-Owner" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Owner")]; found {
		var XBearerOwner string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Owner, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Owner", valueList[0], &XBearerOwner, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Owner: %s", err))
		}

		params.XBearerOwner = &XBearerOwner
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnsignedBearerToken(ctx, params)
	return err
}

// OptionsV2AuthSessionToken converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsV2AuthSessionToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsV2AuthSessionToken(ctx)
	return err
}

// V2AuthSessionToken converts echo context to params.
func (w *ServerInterfaceWrapper) V2AuthSessionToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.V2AuthSessionToken(ctx)
	return err
}

// OptionsV2FormAuthSessionToken converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsV2FormAuthSessionToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsV2FormAuthSessionToken(ctx)
	return err
}

// V2CompleteAuthSessionToken converts echo context to params.
func (w *ServerInterfaceWrapper) V2CompleteAuthSessionToken(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.V2CompleteAuthSessionToken(ctx)
	return err
}

// OptionsV2SearchObjects converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsV2SearchObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId string

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsV2SearchObjects(ctx, containerId)
	return err
}

// V2SearchObjects converts echo context to params.
func (w *ServerInterfaceWrapper) V2SearchObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params V2SearchObjectsParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Session-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Session-Token")]; found {
		var XSessionToken SessionToken
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Session-Token, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Session-Token", valueList[0], &XSessionToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Session-Token: %s", err))
		}

		params.XSessionToken = &XSessionToken
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.V2SearchObjects(ctx, containerId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/accounting/balance/:address", wrapper.GetBalance)
	router.OPTIONS(baseURL+"/v1/accounting/balance/:address", wrapper.OptionsBalance)
	router.OPTIONS(baseURL+"/v1/auth", wrapper.OptionsAuth)
	router.POST(baseURL+"/v1/auth", wrapper.Auth)
	router.GET(baseURL+"/v1/auth/bearer", wrapper.FormBinaryBearer)
	router.OPTIONS(baseURL+"/v1/auth/bearer", wrapper.OptionsAuthBearer)
	router.GET(baseURL+"/v1/containers", wrapper.ListContainers)
	router.OPTIONS(baseURL+"/v1/containers", wrapper.OptionsContainersPutList)
	router.POST(baseURL+"/v1/containers", wrapper.PostContainer)
	router.PUT(baseURL+"/v1/containers", wrapper.PutContainer)
	router.DELETE(baseURL+"/v1/containers/:containerId", wrapper.DeleteContainer)
	router.GET(baseURL+"/v1/containers/:containerId", wrapper.GetContainer)
	router.OPTIONS(baseURL+"/v1/containers/:containerId", wrapper.OptionsContainersGetDelete)
	router.GET(baseURL+"/v1/containers/:containerId/eacl", wrapper.GetContainerEACL)
	router.OPTIONS(baseURL+"/v1/containers/:containerId/eacl", wrapper.OptionsContainersEACL)
	router.PUT(baseURL+"/v1/containers/:containerId/eacl", wrapper.PutContainerEACL)
	router.GET(baseURL+"/v1/gateway", wrapper.GatewayMetadata)
	router.OPTIONS(baseURL+"/v1/gateway", wrapper.OptionsGatewayMetadata)
	router.GET(baseURL+"/v1/network-info", wrapper.GetNetworkInfo)
	router.OPTIONS(baseURL+"/v1/network-info", wrapper.OptionsNetworkInfo)
	router.OPTIONS(baseURL+"/v1/objects/:containerId", wrapper.NewOptionsUploadContainerObject)
	router.POST(baseURL+"/v1/objects/:containerId", wrapper.NewUploadContainerObject)
	router.GET(baseURL+"/v1/objects/:containerId/by_attribute/:attrKey/:attrVal", wrapper.NewGetByAttribute)
	router.HEAD(baseURL+"/v1/objects/:containerId/by_attribute/:attrKey/:attrVal", wrapper.NewHeadByAttribute)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/by_attribute/:attrKey/:attrVal", wrapper.NewOptionsByAttribute)
	router.GET(baseURL+"/v1/objects/:containerId/by_id/:objectId", wrapper.NewGetContainerObject)
	router.HEAD(baseURL+"/v1/objects/:containerId/by_id/:objectId", wrapper.NewHeadContainerObject)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/by_id/:objectId", wrapper.NewOptionsContainerObject)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/search", wrapper.OptionsObjectsSearch)
	router.POST(baseURL+"/v1/objects/:containerId/search", wrapper.SearchObjects)
	router.DELETE(baseURL+"/v1/objects/:containerId/:objectId", wrapper.DeleteObject)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/:objectId", wrapper.OptionsObjectsGetDelete)
	router.OPTIONS(baseURL+"/v2/auth/bearer", wrapper.OptionsUnsignedBearerToken)
	router.POST(baseURL+"/v2/auth/bearer", wrapper.UnsignedBearerToken)
	router.OPTIONS(baseURL+"/v2/auth/session", wrapper.OptionsV2AuthSessionToken)
	router.POST(baseURL+"/v2/auth/session", wrapper.V2AuthSessionToken)
	router.OPTIONS(baseURL+"/v2/auth/session/complete", wrapper.OptionsV2FormAuthSessionToken)
	router.POST(baseURL+"/v2/auth/session/complete", wrapper.V2CompleteAuthSessionToken)
	router.OPTIONS(baseURL+"/v2/objects/:containerId/search", wrapper.OptionsV2SearchObjects)
	router.POST(baseURL+"/v2/objects/:containerId/search", wrapper.V2SearchObjects)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
