// Package apiserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package apiserver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
	CookieAuthScopes = "CookieAuth.Scopes"
)

// Defines values for Action.
const (
	ALLOW Action = "ALLOW"
	DENY  Action = "DENY"
)

// Defines values for ErrorType.
const (
	API ErrorType = "API"
	GW  ErrorType = "GW"
)

// Defines values for HeaderType.
const (
	OBJECT  HeaderType = "OBJECT"
	REQUEST HeaderType = "REQUEST"
	SERVICE HeaderType = "SERVICE"
)

// Defines values for MatchType.
const (
	STRINGEQUAL    MatchType = "STRING_EQUAL"
	STRINGNOTEQUAL MatchType = "STRING_NOT_EQUAL"
)

// Defines values for Operation.
const (
	OperationDELETE    Operation = "DELETE"
	OperationGET       Operation = "GET"
	OperationHEAD      Operation = "HEAD"
	OperationPUT       Operation = "PUT"
	OperationRANGE     Operation = "RANGE"
	OperationRANGEHASH Operation = "RANGEHASH"
	OperationSEARCH    Operation = "SEARCH"
)

// Defines values for Role.
const (
	KEYS   Role = "KEYS"
	OTHERS Role = "OTHERS"
	SYSTEM Role = "SYSTEM"
	USER   Role = "USER"
)

// Defines values for SearchMatch.
const (
	MatchCommonPrefix   SearchMatch = "MatchCommonPrefix"
	MatchNotPresent     SearchMatch = "MatchNotPresent"
	MatchNumGE          SearchMatch = "MatchNumGE"
	MatchNumGT          SearchMatch = "MatchNumGT"
	MatchNumLE          SearchMatch = "MatchNumLE"
	MatchNumLT          SearchMatch = "MatchNumLT"
	MatchStringEqual    SearchMatch = "MatchStringEqual"
	MatchStringNotEqual SearchMatch = "MatchStringNotEqual"
)

// Defines values for TokenType.
const (
	Container TokenType = "container"
	Object    TokenType = "object"
)

// Defines values for Verb.
const (
	VerbDELETE  Verb = "DELETE"
	VerbPUT     Verb = "PUT"
	VerbSETEACL Verb = "SETEACL"
)

// Action Rule execution result action in NeoFS EACL. Either allows or denies access if the rule's filters match.
type Action string

// Address Address of the object in NeoFS.
type Address struct {
	ContainerId string `json:"containerId"`
	ObjectId    string `json:"objectId"`
}

// AddressForUpload Address of the object in NeoFS.
type AddressForUpload struct {
	ContainerId string `json:"container_id"`
	ObjectId    string `json:"object_id"`
}

// Attribute Attribute is a pair of strings that can be attached to a container or an object.
type Attribute struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Balance defines model for Balance.
type Balance struct {
	Address   string `json:"address"`
	Precision uint32 `json:"precision"`
	Value     string `json:"value"`
}

// Bearer Bearer token that is expected to be formed.
type Bearer struct {
	// Container Container session token rule.
	Container *Rule    `json:"container,omitempty"`
	Name      string   `json:"name,omitempty"`
	Object    []Record `json:"object"`
}

// BinaryBearer Bearer token for object operations that is represented in binary form.
type BinaryBearer struct {
	// Token Base64 encoded bearer token.
	Token string `json:"token"`
}

// ContainerInfo Information about container.
type ContainerInfo struct {
	Attributes []Attribute `json:"attributes"`
	BasicAcl   string      `json:"basicAcl"`

	// CannedAcl The friendly name for the basicAcl field.
	CannedAcl       *string `json:"cannedAcl,omitempty"`
	ContainerId     string  `json:"containerId"`
	ContainerName   string  `json:"containerName"`
	OwnerId         string  `json:"ownerId"`
	PlacementPolicy string  `json:"placementPolicy"`
	Version         string  `json:"version"`
}

// ContainerList List of containers info
type ContainerList struct {
	Containers []ContainerInfo `json:"containers"`
	Size       int             `json:"size"`
}

// ContainerPostInfo <p>Request body to create container. To specify container name use appropriate property (name provided in attributes will be ignored).<p>
// <p>To create a container you must provide <code>PlacementPolicy</code> and <code>BasicACL</code>.</p>
//
// <h5>Placement policy</h5>
// <p>Placement policy allows you control where and how the container (and its object) is stored. For example, you want to store 3 copies of every object, so you can use the following policy:</p>
// <pre><code>REP 3</code></pre>
// <p><a href="https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/02-policy.md">More about policy</a>.</p>
//
// <h5>Basic ACL</h5>
// <p>Basic ACL is a part of the container structure, and it is always created simultaneously with the container. Therefore, it is never subject to any changes. It is a 32-bit integer with a bit field in the following format:</p>
// <p><img src="https://raw.githubusercontent.com/nspcc-dev/neofs-spec/046e623dc2d8134ab2b85fcaf831077d574561a2/01-arch/pic/acl-basic-private.svg" alt="ACL Basic"></p>
//
// <table>
//
//	<thead>
//	    <tr>
//	        <th>Symbol</th>
//	        <th>Meaning</th>
//	        <th>Description</th>
//	    </tr>
//	</thead>
//	<tbody>
//	    <tr>
//	        <td>B</td>
//	        <td>Bearer</td>
//	        <td>Allows using Bear Token ACL rules to replace eACL rules</td>
//	    </tr>
//	    <tr>
//	        <td>U</td>
//	        <td>User</td>
//	        <td>The owner of the container identified by the public key linked to the container</td>
//	    </tr>
//	    <tr>
//	        <td>S</td>
//	        <td>System</td>
//	        <td>Inner Ring and/or container nodes in the current version of network map. IR nodes can only perform <code>GetRangeHash</code>, <code>Head</code>, and <code>Search</code> necessary for data audit. Container nodes can only do things required for the replication.</td>
//	    </tr>
//	    <tr>
//	        <td>O</td>
//	        <td>Others</td>
//	        <td>Clients that do not match any of the categories above</td>
//	    </tr>
//	    <tr>
//	        <td>F</td>
//	        <td>Final</td>
//	        <td>Flag denying Extended ACL. If set, Basic ACL check is final, Extended ACL is ignored</td>
//	    </tr>
//	    <tr>
//	        <td>X</td>
//	        <td>Sticky</td>
//	        <td>Flag denying different owners of the request and the object. If set, object in <code>Put</code> request must have one <code>Owner</code> and be signed with the same signature. If not set, the object must be correct but can be of any owner. The nodes falling for <code>SYSTEM</code> role are exceptions from this rule. For them, the bit is ignored.</td>
//	    </tr>
//	    <tr>
//	        <td>0</td>
//	        <td>Deny</td>
//	        <td>Denies operation of the identified category</td>
//	    </tr>
//	    <tr>
//	        <td>1</td>
//	        <td>Allow</td>
//	        <td>Allows operation of the identified category</td>
//	    </tr>
//	</tbody>
//
// </table>
// <p>To upload objects with a bearer token your container must have Bearer bits set. For example, you can use <code>0x0FBFBFFF</code> or predefined <code>eacl-public-read-write</code> values.</p>
// <p>Also, don't forget to set appropriate eACL to restrict your container.</p>
// <p><a href="https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/07-acl.md">More about ACL</a>.</p>
type ContainerPostInfo struct {
	Attributes      []Attribute `json:"attributes,omitempty"`
	BasicAcl        string      `json:"basicAcl,omitempty"`
	ContainerName   string      `json:"containerName,omitempty"`
	PlacementPolicy string      `json:"placementPolicy,omitempty"`
}

// Eacl EACL NeoFS table.
type Eacl struct {
	ContainerId string   `json:"containerId"`
	Records     []Record `json:"records"`
}

// ErrorResponse <p>Error response.</p>
// <p>More about NeoFS status code you can find
//
//	<a href="https://github.com/nspcc-dev/neofs-spec/blob/master/20-api-v2/status.md">here</a>.</p>
type ErrorResponse struct {
	Code    uint32 `json:"code,omitempty"`
	Message string `json:"message"`

	// Type Error type. Allow determine source of the error.
	Type ErrorType `json:"type"`
}

// ErrorType Error type. Allow determine source of the error.
type ErrorType string

// Filter Filter in NeoFS EACL to check particular properties of the request or the object.
type Filter struct {
	// HeaderType Enumeration of possible sources of Headers to apply filters in NeoFS EACL.
	HeaderType HeaderType `json:"headerType"`
	Key        string     `json:"key"`

	// MatchType Match type in NeoFS EACL filter.
	MatchType MatchType `json:"matchType"`
	Value     string    `json:"value"`
}

// HeaderType Enumeration of possible sources of Headers to apply filters in NeoFS EACL.
type HeaderType string

// MatchType Match type in NeoFS EACL filter.
type MatchType string

// NetworkInfoOK Network information from NeoFS.
type NetworkInfoOK struct {
	AuditFee                   uint64 `json:"auditFee"`
	ContainerFee               uint64 `json:"containerFee"`
	EpochDuration              uint64 `json:"epochDuration"`
	HomomorphicHashingDisabled bool   `json:"homomorphicHashingDisabled"`
	MaxObjectSize              uint64 `json:"maxObjectSize"`
	NamedContainerFee          uint64 `json:"namedContainerFee"`
	StoragePrice               uint64 `json:"storagePrice"`
	WithdrawalFee              uint64 `json:"withdrawalFee"`
}

// ObjectBaseInfo Basic object information.
type ObjectBaseInfo struct {
	// Address Address of the object in NeoFS.
	Address  Address `json:"address"`
	FilePath *string `json:"filePath,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// ObjectBaseInfoV2 Basic object information.
type ObjectBaseInfoV2 struct {
	Attributes map[string]interface{} `json:"attributes"`
	ObjectId   string                 `json:"objectId"`
}

// ObjectInfo Object information.
type ObjectInfo struct {
	Attributes  []Attribute `json:"attributes"`
	ContainerId string      `json:"containerId"`
	ObjectId    string      `json:"objectId"`

	// ObjectSize Object full payload size
	ObjectSize uint64 `json:"objectSize"`
	OwnerId    string `json:"ownerId"`

	// Payload Base64 encoded object payload
	Payload *string `json:"payload,omitempty"`

	// PayloadSize Payload size in response
	PayloadSize int64 `json:"payloadSize"`
}

// ObjectList List of objects.
type ObjectList struct {
	Objects []ObjectBaseInfo `json:"objects"`
	Size    int              `json:"size"`
}

// ObjectListV2 List of objects.
type ObjectListV2 struct {
	// Cursor Value to start the next batch from.
	Cursor  string             `json:"cursor"`
	Objects []ObjectBaseInfoV2 `json:"objects"`
}

// ObjectUpload <p>Request body to create object.</p>
// <p>To create an object you must provide <code>containerId</code> and <code>fileName</code>.
// Additionally, you can provide <code>payload</code> (base64 encoded data) and <code>attributes</code>.</p>
//
// <p>Attribute is key-value data that is stored with the object. Key and value must be in UTF-8 format and must not be empty.</p>
//
// <p>Valid attribute:</p>
// <ul>
//
//	<li><code>MyAttribute: 'some value'</code></li>
//
// </ul>
//
// <p>Invalid attribute:</p>
// <ul>
//
//	<li><code>MyAttribute: ''</code></li>
//
// </ul>
//
// <p>Also, you can use this attribute to further object searching.</p>
type ObjectUpload struct {
	Attributes  []Attribute `json:"attributes,omitempty"`
	ContainerId string      `json:"containerId"`
	FileName    string      `json:"fileName"`
	Payload     *string     `json:"payload,omitempty"`
}

// Operation Request's operation type to match in NeoFS EACL if the rule is applicable to a particular request.
type Operation string

// PostContainerOK defines model for PostContainerOK.
type PostContainerOK struct {
	ContainerId string `json:"containerId"`
}

// Record A single NeoFS EACL rule.
type Record struct {
	// Action Rule execution result action in NeoFS EACL. Either allows or denies access if the rule's filters match.
	Action  Action   `json:"action"`
	Filters []Filter `json:"filters"`

	// Operation Request's operation type to match in NeoFS EACL if the rule is applicable to a particular request.
	Operation Operation `json:"operation"`
	Targets   []Target  `json:"targets"`
}

// Role Role for target in EACL.
type Role string

// Rule Container session token rule.
type Rule struct {
	ContainerId *string `json:"containerId,omitempty"`

	// Verb Verb that describes the allowed container operation for token.
	Verb Verb `json:"verb"`
}

// SearchFilter Search filter to find objects.
type SearchFilter struct {
	Key string `json:"key"`

	// Match Search match type.
	Match SearchMatch `json:"match"`
	Value string      `json:"value"`
}

// SearchFilters List of SearchFilter elements.
type SearchFilters struct {
	// Filters It must contain 7 filters as maximum.
	Filters []SearchFilter `json:"filters"`
}

// SearchMatch Search match type.
type SearchMatch string

// SearchRequest List of SearchFilter elements.
type SearchRequest struct {
	// Attributes Attribute list to be returned for each object. It must contain 7 attributes as maximum.
	Attributes []string `json:"attributes"`

	// Filters It must contain 7 filters as maximum.
	Filters []SearchFilter `json:"filters"`
}

// SuccessResponse Success response.
type SuccessResponse struct {
	Success bool `json:"success"`
}

// Target Target to apply the ACL rule. Can be a subject's role class or a list of public keys to match (KEYS role).
type Target struct {
	Keys []string `json:"keys"`

	// Role Role for target in EACL.
	Role Role `json:"role"`
}

// TokenResponse Base64 encoded marshaled token (for container or for object operations).
type TokenResponse struct {
	Name  *string `json:"name,omitempty"`
	Token string  `json:"token"`

	// Type Type of token.
	Type TokenType `json:"type"`
}

// TokenType Type of token.
type TokenType string

// Verb Verb that describes the allowed container operation for token.
type Verb string

// AttrKey defines model for attrKey.
type AttrKey = string

// AttrVal defines model for attrVal.
type AttrVal = string

// ContainerId defines model for containerId.
type ContainerId = string

// ObjectId defines model for objectId.
type ObjectId = string

// Range defines model for range.
type Range = string

// SignatureKeyParam defines model for signatureKeyParam.
type SignatureKeyParam = string

// SignatureParam defines model for signatureParam.
type SignatureParam = string

// SignatureScheme defines model for signatureScheme.
type SignatureScheme = bool

// AuthJSONBody defines parameters for Auth.
type AuthJSONBody = []Bearer

// AuthParams defines parameters for Auth.
type AuthParams struct {
	// XBearerOwnerId Owner Id (wallet address) that will sign the token.
	XBearerOwnerId string `json:"X-Bearer-Owner-Id"`

	// XBearerLifetime Token lifetime in epoch.
	XBearerLifetime *int `json:"X-Bearer-Lifetime,omitempty"`

	// XBearerForAllUsers Form token for all users or only for this gate.
	XBearerForAllUsers *bool `json:"X-Bearer-For-All-Users,omitempty"`
}

// FormBinaryBearerParams defines parameters for FormBinaryBearer.
type FormBinaryBearerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// ListContainersParams defines parameters for ListContainers.
type ListContainersParams struct {
	// OwnerId Base58 encoded owner id.
	OwnerId string `form:"ownerId" json:"ownerId"`

	// Offset The number of containers to skip before starting to collect the result set.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of containers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostContainerParams defines parameters for PostContainer.
type PostContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// NameScopeGlobal Provide this parameter to register container name in NNS service.
	NameScopeGlobal *bool `form:"name-scope-global,omitempty" json:"name-scope-global,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// PutContainerParams defines parameters for PutContainer.
type PutContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// NameScopeGlobal Provide this parameter to register container name in NNS service.
	NameScopeGlobal *bool `form:"name-scope-global,omitempty" json:"name-scope-global,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// DeleteContainerParams defines parameters for DeleteContainer.
type DeleteContainerParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// PutContainerEACLParams defines parameters for PutContainerEACL.
type PutContainerEACLParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// GetContainerObjectParams defines parameters for GetContainerObject.
type GetContainerObjectParams struct {
	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// HeadContainerObjectParams defines parameters for HeadContainerObject.
type HeadContainerObjectParams struct {
	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// GetByAttributeParams defines parameters for GetByAttribute.
type GetByAttributeParams struct {
	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// HeadByAttributeParams defines parameters for HeadByAttribute.
type HeadByAttributeParams struct {
	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`
}

// PutObjectParams defines parameters for PutObject.
type PutObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewOptionsUploadContainerObjectParams defines parameters for NewOptionsUploadContainerObject.
type NewOptionsUploadContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewUploadContainerObjectParams defines parameters for NewUploadContainerObject.
type NewUploadContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// XAttributes All attributes are in a JSON-formatted map of key-value pairs, where the key is the
	// attribute name and the value is the attribute value.
	// You can also use the special attribute:
	// - `__NEOFS__EXPIRATION_EPOCH` - specifies the expiration epoch used by NeoFS.
	// This attribute should be used if you are familiar with the NeoFS epoch system.
	// More information can be found here: [NeoFS Specifications](https://github.com/nspcc-dev/neofs-spec/blob/master/01-arch/01-netmap.md).
	// Instead of this attribute you can use one of `X-Neofs-Expiration-*` headers below.
	XAttributes *string `json:"X-Attributes,omitempty"`

	// XNeofsExpirationRFC3339 Specifies the expiration time in RFC3339 format. Examples:
	// - "2024-12-31T23:59:59Z" represents the last moment of 2024 in UTC.
	// - "2024-12-31T15:59:59-08:00" represents 3:59 PM on December 31, 2024, Pacific Time.\
	// It will be rounded to the next epoch and used to set the `__NEOFS__EXPIRATION_EPOCH`
	// attribute of the created object.
	XNeofsExpirationRFC3339 *string `json:"X-Neofs-Expiration-RFC3339,omitempty"`

	// XNeofsExpirationTimestamp Specifies the exact timestamp of object expiration. It will be rounded to the next epoch and stored in the `__NEOFS__EXPIRATION_EPOCH` attribute of the created object.
	XNeofsExpirationTimestamp *string `json:"X-Neofs-Expiration-Timestamp,omitempty"`

	// XNeofsExpirationDuration Specifies the duration until object expiration in Go's duration format. Examples:
	// - "300s" represents 5 minutes.
	// - "2h45m" represents 2 hours and 45 minutes. \
	// It will be rounded to the next epoch and used to set the `__NEOFS__EXPIRATION_EPOCH` attribute of the created object.
	XNeofsExpirationDuration *string `json:"X-Neofs-Expiration-Duration,omitempty"`
}

// NewGetByAttributeParams defines parameters for NewGetByAttribute.
type NewGetByAttributeParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// Range Request a specific range of bytes from the object.
	Range *Range `json:"Range,omitempty"`
}

// NewHeadByAttributeParams defines parameters for NewHeadByAttribute.
type NewHeadByAttributeParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This makes the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewOptionsByAttributeParams defines parameters for NewOptionsByAttribute.
type NewOptionsByAttributeParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewGetContainerObjectParams defines parameters for NewGetContainerObject.
type NewGetContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`

	// Range Request a specific range of bytes from the object.
	Range *Range `json:"Range,omitempty"`
}

// NewHeadContainerObjectParams defines parameters for NewHeadContainerObject.
type NewHeadContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Download Set the Content-Disposition header as attachment in response. This make the browser to download object as file instead of showing it on the page.
	Download *string `form:"download,omitempty" json:"download,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// NewOptionsContainerObjectParams defines parameters for NewOptionsContainerObject.
type NewOptionsContainerObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// SearchObjectsParams defines parameters for SearchObjects.
type SearchObjectsParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Offset The number of containers to skip before starting to collect the result set.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The numbers of containers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// GetObjectInfoParams defines parameters for GetObjectInfo.
type GetObjectInfoParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// RangeOffset Range offset to start reading data.
	RangeOffset *int64 `form:"range-offset,omitempty" json:"range-offset,omitempty"`

	// RangeLength Length of data range.
	RangeLength *int64 `form:"range-length,omitempty" json:"range-length,omitempty"`

	// MaxPayloadSize Max payload size (in bytes) that can be included in the response.
	// If the actual size is greater than this params the payload won't be included in the response.
	MaxPayloadSize *int `form:"max-payload-size,omitempty" json:"max-payload-size,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// UploadContainerObjectMultipartBody defines parameters for UploadContainerObject.
type UploadContainerObjectMultipartBody struct {
	// Payload The file to upload.  If no file is present in this field, any other field name will be accepted, except for an empty one.
	Payload *openapi_types.File `json:"payload,omitempty"`
}

// UploadContainerObjectParams defines parameters for UploadContainerObject.
type UploadContainerObjectParams struct {
	// XAttributeFilename This attribute, in any combination of upper/lower case, will be added to the object as the `FileName` attribute. It will also be returned as the `FileName` attribute in GET/HEAD API calls for the object (/get/{containerId}/{objectId}) and the `name` in POST call search in a container (/objects/{containerId}/search).
	XAttributeFilename *string `json:"X-Attribute-Filename,omitempty"`

	// XAttributeFilepath This attribute, in any combination of upper/lower case, will be added to the object as the `FilePath` attribute. It will also be returned as the `FilePath` attribute in GET/HEAD API calls for the object (/get/{containerId}/{objectId}) or the `filePath` in POST call search in a container (/objects/{containerId}/search).
	XAttributeFilepath *string `json:"X-Attribute-Filepath,omitempty"`
}

// V2SearchObjectsParams defines parameters for V2SearchObjects.
type V2SearchObjectsParams struct {
	// WalletConnect Use wallet connect signature scheme or native NeoFS signature.
	WalletConnect *SignatureScheme `form:"walletConnect,omitempty" json:"walletConnect,omitempty"`

	// Cursor Value to start the next batch from. It returns the first elements batch if empty value passed. You should take `cursor` value from previous response to be able to list items.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The numbers of objects to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// XBearerSignature Base64 encoded signature for bearer token.
	XBearerSignature *SignatureParam `json:"X-Bearer-Signature,omitempty"`

	// XBearerSignatureKey Hex encoded the public part of the key that signed the bearer token.
	XBearerSignatureKey *SignatureKeyParam `json:"X-Bearer-Signature-Key,omitempty"`
}

// AuthJSONRequestBody defines body for Auth for application/json ContentType.
type AuthJSONRequestBody = AuthJSONBody

// PutObjectJSONRequestBody defines body for PutObject for application/json ContentType.
type PutObjectJSONRequestBody = ObjectUpload

// UploadContainerObjectMultipartRequestBody defines body for UploadContainerObject for multipart/form-data ContentType.
type UploadContainerObjectMultipartRequestBody UploadContainerObjectMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get balance in NeoFS
	// (GET /v1/accounting/balance/{address})
	GetBalance(ctx echo.Context, address string) error

	// (OPTIONS /v1/accounting/balance/{address})
	OptionsBalance(ctx echo.Context, address string) error

	// (OPTIONS /v1/auth)
	OptionsAuth(ctx echo.Context) error
	// Form bearer token to further requests
	// (POST /v1/auth)
	Auth(ctx echo.Context, params AuthParams) error
	// Form binary bearer token
	// (GET /v1/auth/bearer)
	FormBinaryBearer(ctx echo.Context, params FormBinaryBearerParams) error

	// (OPTIONS /v1/auth/bearer)
	OptionsAuthBearer(ctx echo.Context) error
	// Get list of containers
	// (GET /v1/containers)
	ListContainers(ctx echo.Context, params ListContainersParams) error

	// (OPTIONS /v1/containers)
	OptionsContainersPutList(ctx echo.Context) error
	// Create new container in NeoFS
	// (POST /v1/containers)
	PostContainer(ctx echo.Context, params PostContainerParams) error
	// Create new container in NeoFS. Use POST method to create a container.
	// (PUT /v1/containers)
	PutContainer(ctx echo.Context, params PutContainerParams) error
	// Delete container by id
	// (DELETE /v1/containers/{containerId})
	DeleteContainer(ctx echo.Context, containerId ContainerId, params DeleteContainerParams) error
	// Get container by id
	// (GET /v1/containers/{containerId})
	GetContainer(ctx echo.Context, containerId ContainerId) error

	// (OPTIONS /v1/containers/{containerId})
	OptionsContainersGetDelete(ctx echo.Context, containerId ContainerId) error
	// Get container EACL by id
	// (GET /v1/containers/{containerId}/eacl)
	GetContainerEACL(ctx echo.Context, containerId ContainerId) error

	// (OPTIONS /v1/containers/{containerId}/eacl)
	OptionsContainersEACL(ctx echo.Context, containerId ContainerId) error
	// Set container EACL by id
	// (PUT /v1/containers/{containerId}/eacl)
	PutContainerEACL(ctx echo.Context, containerId ContainerId, params PutContainerEACLParams) error
	// Get object by container ID and object ID. Also returns custom users' header attributes `X-Attribute-*`. It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section. Please use `/objects/{containerId}/by_id/{objectId}` API.
	// (GET /v1/get/{containerId}/{objectId})
	GetContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params GetContainerObjectParams) error
	// Get object info (head) by container ID and object ID. Also returns custom users' header attributes `X-Attribute-*`.
	// (HEAD /v1/get/{containerId}/{objectId})
	HeadContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params HeadContainerObjectParams) error

	// (OPTIONS /v1/get/{containerId}/{objectId})
	OptionsContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId) error
	// Find and get an object (payload and attributes) by a specific attribute. If more than one object is found, an arbitrary one will be returned. It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section. Please use `/objects/{containerId}/by_attribute/{attrKey}/{attrVal}` API.
	// (GET /v1/get_by_attribute/{containerId}/{attrKey}/{attrVal})
	GetByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params GetByAttributeParams) error
	// Get object attributes by a specific attribute. If more than one object is found, an arbitrary one will be used to get attributes.
	// (HEAD /v1/get_by_attribute/{containerId}/{attrKey}/{attrVal})
	HeadByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params HeadByAttributeParams) error

	// (OPTIONS /v1/get_by_attribute/{containerId}/{attrKey}/{attrVal})
	OptionsByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal) error
	// Get network settings
	// (GET /v1/network-info)
	GetNetworkInfo(ctx echo.Context) error

	// (OPTIONS /v1/network-info)
	OptionsNetworkInfo(ctx echo.Context) error

	// (OPTIONS /v1/objects)
	OptionsObjectsPut(ctx echo.Context) error
	// Upload object to NeoFS
	// (PUT /v1/objects)
	PutObject(ctx echo.Context, params PutObjectParams) error

	// (OPTIONS /v1/objects/{containerId})
	NewOptionsUploadContainerObject(ctx echo.Context, containerId ContainerId, params NewOptionsUploadContainerObjectParams) error
	// Upload object to NeoFS
	// (POST /v1/objects/{containerId})
	NewUploadContainerObject(ctx echo.Context, containerId ContainerId, params NewUploadContainerObjectParams) error
	// Find and get an object (payload and attributes) by a specific attribute. If more than one object is found, the latest one (wrt `Timestamp` attribute) from the first 1000 of search results will be returned (use `/objects/{containerId}/search` API if this is not desired). It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section. Also, returns custom users' object attributes in header `X-Attributes`.
	// (GET /v1/objects/{containerId}/by_attribute/{attrKey}/{attrVal})
	NewGetByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params NewGetByAttributeParams) error
	// Get object attributes by a specific attribute. If more than one object is found, the latest one (wrt `Timestamp` attribute) from the first 1000 of  search results will be returned (use `/objects/{containerId}/search` API if this is not desired). Also, returns custom users' object attributes in header `X-Attributes`.
	// (HEAD /v1/objects/{containerId}/by_attribute/{attrKey}/{attrVal})
	NewHeadByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params NewHeadByAttributeParams) error

	// (OPTIONS /v1/objects/{containerId}/by_attribute/{attrKey}/{attrVal})
	NewOptionsByAttribute(ctx echo.Context, containerId ContainerId, attrKey AttrKey, attrVal AttrVal, params NewOptionsByAttributeParams) error
	// Get object by container ID and object ID. Also, returns custom users' object attributes in header `X-Attributes`. It returns the MIME type based on headers or object contents, so the actual Content-Type can differ from the list in the "Response content type" section.
	// (GET /v1/objects/{containerId}/by_id/{objectId})
	NewGetContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params NewGetContainerObjectParams) error
	// Get object info (head) by container ID and object ID. Also, returns custom users' object attributes in header `X-Attributes`.
	// (HEAD /v1/objects/{containerId}/by_id/{objectId})
	NewHeadContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params NewHeadContainerObjectParams) error

	// (OPTIONS /v1/objects/{containerId}/by_id/{objectId})
	NewOptionsContainerObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params NewOptionsContainerObjectParams) error

	// (OPTIONS /v1/objects/{containerId}/search)
	OptionsObjectsSearch(ctx echo.Context, containerId string) error
	// Search objects by filters
	// (POST /v1/objects/{containerId}/search)
	SearchObjects(ctx echo.Context, containerId ContainerId, params SearchObjectsParams) error
	// Remove object from NeoFS
	// (DELETE /v1/objects/{containerId}/{objectId})
	DeleteObject(ctx echo.Context, containerId ContainerId, objectId ObjectId, params DeleteObjectParams) error
	// Get object info by address. Please use `/objects/{containerId}/by_id/{objectId}` API.
	// (GET /v1/objects/{containerId}/{objectId})
	GetObjectInfo(ctx echo.Context, containerId ContainerId, objectId ObjectId, params GetObjectInfoParams) error

	// (OPTIONS /v1/objects/{containerId}/{objectId})
	OptionsObjectsGetDelete(ctx echo.Context, containerId ContainerId, objectId ObjectId) error

	// (OPTIONS /v1/upload/{containerId})
	OptionsUploadContainerObject(ctx echo.Context, containerId ContainerId) error
	// Upload object to NeoFS. Please use `/objects/{containerId}` API.
	// (POST /v1/upload/{containerId})
	UploadContainerObject(ctx echo.Context, containerId ContainerId, params UploadContainerObjectParams) error
	// Search objects by filters
	// (POST /v2/objects/{containerId}/search)
	V2SearchObjects(ctx echo.Context, containerId ContainerId, params V2SearchObjectsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetBalance converts echo context to params.
func (w *ServerInterfaceWrapper) GetBalance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBalance(ctx, address)
	return err
}

// OptionsBalance converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsBalance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsBalance(ctx, address)
	return err
}

// OptionsAuth converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsAuth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsAuth(ctx)
	return err
}

// Auth converts echo context to params.
func (w *ServerInterfaceWrapper) Auth(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Bearer-Owner-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Owner-Id")]; found {
		var XBearerOwnerId string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Owner-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Owner-Id", valueList[0], &XBearerOwnerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Owner-Id: %s", err))
		}

		params.XBearerOwnerId = XBearerOwnerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Bearer-Owner-Id is required, but not found"))
	}
	// ------------- Optional header parameter "X-Bearer-Lifetime" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Lifetime")]; found {
		var XBearerLifetime int
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Lifetime, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Lifetime", valueList[0], &XBearerLifetime, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Lifetime: %s", err))
		}

		params.XBearerLifetime = &XBearerLifetime
	}
	// ------------- Optional header parameter "X-Bearer-For-All-Users" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-For-All-Users")]; found {
		var XBearerForAllUsers bool
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-For-All-Users, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-For-All-Users", valueList[0], &XBearerForAllUsers, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-For-All-Users: %s", err))
		}

		params.XBearerForAllUsers = &XBearerForAllUsers
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Auth(ctx, params)
	return err
}

// FormBinaryBearer converts echo context to params.
func (w *ServerInterfaceWrapper) FormBinaryBearer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params FormBinaryBearerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.FormBinaryBearer(ctx, params)
	return err
}

// OptionsAuthBearer converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsAuthBearer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsAuthBearer(ctx)
	return err
}

// ListContainers converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListContainersParams
	// ------------- Required query parameter "ownerId" -------------

	err = runtime.BindQueryParameter("form", true, true, "ownerId", ctx.QueryParams(), &params.OwnerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ownerId: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainers(ctx, params)
	return err
}

// OptionsContainersPutList converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersPutList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersPutList(ctx)
	return err
}

// PostContainer converts echo context to params.
func (w *ServerInterfaceWrapper) PostContainer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "name-scope-global" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-scope-global", ctx.QueryParams(), &params.NameScopeGlobal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name-scope-global: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostContainer(ctx, params)
	return err
}

// PutContainer converts echo context to params.
func (w *ServerInterfaceWrapper) PutContainer(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "name-scope-global" -------------

	err = runtime.BindQueryParameter("form", true, false, "name-scope-global", ctx.QueryParams(), &params.NameScopeGlobal)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name-scope-global: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutContainer(ctx, params)
	return err
}

// DeleteContainer converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteContainerParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteContainer(ctx, containerId, params)
	return err
}

// GetContainer converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainer(ctx, containerId)
	return err
}

// OptionsContainersGetDelete converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersGetDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersGetDelete(ctx, containerId)
	return err
}

// GetContainerEACL converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerEACL(ctx, containerId)
	return err
}

// OptionsContainersEACL converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainersEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainersEACL(ctx, containerId)
	return err
}

// PutContainerEACL converts echo context to params.
func (w *ServerInterfaceWrapper) PutContainerEACL(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutContainerEACLParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutContainerEACL(ctx, containerId, params)
	return err
}

// GetContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContainerObjectParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerObject(ctx, containerId, objectId, params)
	return err
}

// HeadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) HeadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadContainerObjectParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HeadContainerObject(ctx, containerId, objectId, params)
	return err
}

// OptionsContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsContainerObject(ctx, containerId, objectId)
	return err
}

// GetByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) GetByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetByAttributeParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// HeadByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) HeadByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadByAttributeParams
	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HeadByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// OptionsByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsByAttribute(ctx, containerId, attrKey, attrVal)
	return err
}

// GetNetworkInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworkInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworkInfo(ctx)
	return err
}

// OptionsNetworkInfo converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsNetworkInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsNetworkInfo(ctx)
	return err
}

// OptionsObjectsPut converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsPut(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsPut(ctx)
	return err
}

// PutObject converts echo context to params.
func (w *ServerInterfaceWrapper) PutObject(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PutObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutObject(ctx, params)
	return err
}

// NewOptionsUploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewOptionsUploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NewOptionsUploadContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewOptionsUploadContainerObject(ctx, containerId, params)
	return err
}

// NewUploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewUploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewUploadContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "X-Attributes" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Attributes")]; found {
		var XAttributes string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Attributes, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Attributes", valueList[0], &XAttributes, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Attributes: %s", err))
		}

		params.XAttributes = &XAttributes
	}
	// ------------- Optional header parameter "X-Neofs-Expiration-RFC3339" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Neofs-Expiration-RFC3339")]; found {
		var XNeofsExpirationRFC3339 string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Neofs-Expiration-RFC3339, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Neofs-Expiration-RFC3339", valueList[0], &XNeofsExpirationRFC3339, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Neofs-Expiration-RFC3339: %s", err))
		}

		params.XNeofsExpirationRFC3339 = &XNeofsExpirationRFC3339
	}
	// ------------- Optional header parameter "X-Neofs-Expiration-Timestamp" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Neofs-Expiration-Timestamp")]; found {
		var XNeofsExpirationTimestamp string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Neofs-Expiration-Timestamp, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Neofs-Expiration-Timestamp", valueList[0], &XNeofsExpirationTimestamp, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Neofs-Expiration-Timestamp: %s", err))
		}

		params.XNeofsExpirationTimestamp = &XNeofsExpirationTimestamp
	}
	// ------------- Optional header parameter "X-Neofs-Expiration-Duration" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Neofs-Expiration-Duration")]; found {
		var XNeofsExpirationDuration string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Neofs-Expiration-Duration, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Neofs-Expiration-Duration", valueList[0], &XNeofsExpirationDuration, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Neofs-Expiration-Duration: %s", err))
		}

		params.XNeofsExpirationDuration = &XNeofsExpirationDuration
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewUploadContainerObject(ctx, containerId, params)
	return err
}

// NewGetByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) NewGetByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewGetByAttributeParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range Range
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Range, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Range: %s", err))
		}

		params.Range = &Range
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewGetByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// NewHeadByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) NewHeadByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewHeadByAttributeParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewHeadByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// NewOptionsByAttribute converts echo context to params.
func (w *ServerInterfaceWrapper) NewOptionsByAttribute(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "attrKey" -------------
	var attrKey AttrKey

	err = runtime.BindStyledParameterWithOptions("simple", "attrKey", ctx.Param("attrKey"), &attrKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrKey: %s", err))
	}

	// ------------- Path parameter "attrVal" -------------
	var attrVal AttrVal

	err = runtime.BindStyledParameterWithOptions("simple", "attrVal", ctx.Param("attrVal"), &attrVal, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter attrVal: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NewOptionsByAttributeParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewOptionsByAttribute(ctx, containerId, attrKey, attrVal, params)
	return err
}

// NewGetContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewGetContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewGetContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}
	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range Range
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Range, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Range: %s", err))
		}

		params.Range = &Range
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewGetContainerObject(ctx, containerId, objectId, params)
	return err
}

// NewHeadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewHeadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params NewHeadContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", ctx.QueryParams(), &params.Download)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter download: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewHeadContainerObject(ctx, containerId, objectId, params)
	return err
}

// NewOptionsContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) NewOptionsContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params NewOptionsContainerObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.NewOptionsContainerObject(ctx, containerId, objectId, params)
	return err
}

// OptionsObjectsSearch converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsSearch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId string

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsSearch(ctx, containerId)
	return err
}

// SearchObjects converts echo context to params.
func (w *ServerInterfaceWrapper) SearchObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchObjectsParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchObjects(ctx, containerId, params)
	return err
}

// DeleteObject converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteObject(ctx, containerId, objectId, params)
	return err
}

// GetObjectInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetObjectInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectInfoParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "range-offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "range-offset", ctx.QueryParams(), &params.RangeOffset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter range-offset: %s", err))
	}

	// ------------- Optional query parameter "range-length" -------------

	err = runtime.BindQueryParameter("form", true, false, "range-length", ctx.QueryParams(), &params.RangeLength)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter range-length: %s", err))
	}

	// ------------- Optional query parameter "max-payload-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-payload-size", ctx.QueryParams(), &params.MaxPayloadSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-payload-size: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetObjectInfo(ctx, containerId, objectId, params)
	return err
}

// OptionsObjectsGetDelete converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsObjectsGetDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// ------------- Path parameter "objectId" -------------
	var objectId ObjectId

	err = runtime.BindStyledParameterWithOptions("simple", "objectId", ctx.Param("objectId"), &objectId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter objectId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsObjectsGetDelete(ctx, containerId, objectId)
	return err
}

// OptionsUploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) OptionsUploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OptionsUploadContainerObject(ctx, containerId)
	return err
}

// UploadContainerObject converts echo context to params.
func (w *ServerInterfaceWrapper) UploadContainerObject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	ctx.Set(CookieAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadContainerObjectParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Attribute-Filename" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Attribute-Filename")]; found {
		var XAttributeFilename string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Attribute-Filename, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Attribute-Filename", valueList[0], &XAttributeFilename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Attribute-Filename: %s", err))
		}

		params.XAttributeFilename = &XAttributeFilename
	}
	// ------------- Optional header parameter "X-Attribute-Filepath" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Attribute-Filepath")]; found {
		var XAttributeFilepath string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Attribute-Filepath, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Attribute-Filepath", valueList[0], &XAttributeFilepath, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Attribute-Filepath: %s", err))
		}

		params.XAttributeFilepath = &XAttributeFilepath
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UploadContainerObject(ctx, containerId, params)
	return err
}

// V2SearchObjects converts echo context to params.
func (w *ServerInterfaceWrapper) V2SearchObjects(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "containerId" -------------
	var containerId ContainerId

	err = runtime.BindStyledParameterWithOptions("simple", "containerId", ctx.Param("containerId"), &containerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerId: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params V2SearchObjectsParams
	// ------------- Optional query parameter "walletConnect" -------------

	err = runtime.BindQueryParameter("form", true, false, "walletConnect", ctx.QueryParams(), &params.WalletConnect)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter walletConnect: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Bearer-Signature" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature")]; found {
		var XBearerSignature SignatureParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature", valueList[0], &XBearerSignature, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature: %s", err))
		}

		params.XBearerSignature = &XBearerSignature
	}
	// ------------- Optional header parameter "X-Bearer-Signature-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Bearer-Signature-Key")]; found {
		var XBearerSignatureKey SignatureKeyParam
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Bearer-Signature-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Bearer-Signature-Key", valueList[0], &XBearerSignatureKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Bearer-Signature-Key: %s", err))
		}

		params.XBearerSignatureKey = &XBearerSignatureKey
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.V2SearchObjects(ctx, containerId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/accounting/balance/:address", wrapper.GetBalance)
	router.OPTIONS(baseURL+"/v1/accounting/balance/:address", wrapper.OptionsBalance)
	router.OPTIONS(baseURL+"/v1/auth", wrapper.OptionsAuth)
	router.POST(baseURL+"/v1/auth", wrapper.Auth)
	router.GET(baseURL+"/v1/auth/bearer", wrapper.FormBinaryBearer)
	router.OPTIONS(baseURL+"/v1/auth/bearer", wrapper.OptionsAuthBearer)
	router.GET(baseURL+"/v1/containers", wrapper.ListContainers)
	router.OPTIONS(baseURL+"/v1/containers", wrapper.OptionsContainersPutList)
	router.POST(baseURL+"/v1/containers", wrapper.PostContainer)
	router.PUT(baseURL+"/v1/containers", wrapper.PutContainer)
	router.DELETE(baseURL+"/v1/containers/:containerId", wrapper.DeleteContainer)
	router.GET(baseURL+"/v1/containers/:containerId", wrapper.GetContainer)
	router.OPTIONS(baseURL+"/v1/containers/:containerId", wrapper.OptionsContainersGetDelete)
	router.GET(baseURL+"/v1/containers/:containerId/eacl", wrapper.GetContainerEACL)
	router.OPTIONS(baseURL+"/v1/containers/:containerId/eacl", wrapper.OptionsContainersEACL)
	router.PUT(baseURL+"/v1/containers/:containerId/eacl", wrapper.PutContainerEACL)
	router.GET(baseURL+"/v1/get/:containerId/:objectId", wrapper.GetContainerObject)
	router.HEAD(baseURL+"/v1/get/:containerId/:objectId", wrapper.HeadContainerObject)
	router.OPTIONS(baseURL+"/v1/get/:containerId/:objectId", wrapper.OptionsContainerObject)
	router.GET(baseURL+"/v1/get_by_attribute/:containerId/:attrKey/:attrVal", wrapper.GetByAttribute)
	router.HEAD(baseURL+"/v1/get_by_attribute/:containerId/:attrKey/:attrVal", wrapper.HeadByAttribute)
	router.OPTIONS(baseURL+"/v1/get_by_attribute/:containerId/:attrKey/:attrVal", wrapper.OptionsByAttribute)
	router.GET(baseURL+"/v1/network-info", wrapper.GetNetworkInfo)
	router.OPTIONS(baseURL+"/v1/network-info", wrapper.OptionsNetworkInfo)
	router.OPTIONS(baseURL+"/v1/objects", wrapper.OptionsObjectsPut)
	router.PUT(baseURL+"/v1/objects", wrapper.PutObject)
	router.OPTIONS(baseURL+"/v1/objects/:containerId", wrapper.NewOptionsUploadContainerObject)
	router.POST(baseURL+"/v1/objects/:containerId", wrapper.NewUploadContainerObject)
	router.GET(baseURL+"/v1/objects/:containerId/by_attribute/:attrKey/:attrVal", wrapper.NewGetByAttribute)
	router.HEAD(baseURL+"/v1/objects/:containerId/by_attribute/:attrKey/:attrVal", wrapper.NewHeadByAttribute)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/by_attribute/:attrKey/:attrVal", wrapper.NewOptionsByAttribute)
	router.GET(baseURL+"/v1/objects/:containerId/by_id/:objectId", wrapper.NewGetContainerObject)
	router.HEAD(baseURL+"/v1/objects/:containerId/by_id/:objectId", wrapper.NewHeadContainerObject)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/by_id/:objectId", wrapper.NewOptionsContainerObject)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/search", wrapper.OptionsObjectsSearch)
	router.POST(baseURL+"/v1/objects/:containerId/search", wrapper.SearchObjects)
	router.DELETE(baseURL+"/v1/objects/:containerId/:objectId", wrapper.DeleteObject)
	router.GET(baseURL+"/v1/objects/:containerId/:objectId", wrapper.GetObjectInfo)
	router.OPTIONS(baseURL+"/v1/objects/:containerId/:objectId", wrapper.OptionsObjectsGetDelete)
	router.OPTIONS(baseURL+"/v1/upload/:containerId", wrapper.OptionsUploadContainerObject)
	router.POST(baseURL+"/v1/upload/:containerId", wrapper.UploadContainerObject)
	router.POST(baseURL+"/v2/objects/:containerId/search", wrapper.V2SearchObjects)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
